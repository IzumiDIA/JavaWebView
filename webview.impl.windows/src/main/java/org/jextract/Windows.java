// Generated by jextract

package org.jextract;

import java.lang.foreign.FunctionDescriptor;
import java.lang.foreign.Linker;
import java.lang.foreign.MemorySegment;
import java.lang.invoke.MethodHandle;

public class Windows {
	
	Windows() {
		// Should not be called directly
	}
	
	private static class GetStdHandle {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_POINTER,
				LayoutUtils.C_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("GetStdHandle"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * HANDLE GetStdHandle(DWORD nStdHandle)
	 *}
	 */
	public static FunctionDescriptor GetStdHandle$descriptor() {
		return GetStdHandle.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * HANDLE GetStdHandle(DWORD nStdHandle)
	 *}
	 */
	public static MethodHandle GetStdHandle$handle() {
		return GetStdHandle.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * HANDLE GetStdHandle(DWORD nStdHandle)
	 *}
	 */
	public static MemorySegment GetStdHandle(int nStdHandle) {
		var mh$ = GetStdHandle.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("GetStdHandle", nStdHandle);
			}
			return (MemorySegment) mh$.invokeExact(nStdHandle);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class SetStdHandle {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_BOOL,
				LayoutUtils.C_LONG,
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("SetStdHandle"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL SetStdHandle(DWORD nStdHandle, HANDLE hHandle)
	 *}
	 */
	public static FunctionDescriptor SetStdHandle$descriptor() {
		return SetStdHandle.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL SetStdHandle(DWORD nStdHandle, HANDLE hHandle)
	 *}
	 */
	public static MethodHandle SetStdHandle$handle() {
		return SetStdHandle.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL SetStdHandle(DWORD nStdHandle, HANDLE hHandle)
	 *}
	 */
	public static boolean SetStdHandle(int nStdHandle, MemorySegment hHandle) {
		var mh$ = SetStdHandle.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("SetStdHandle", nStdHandle, hHandle);
			}
			return (boolean) mh$.invokeExact(nStdHandle, hHandle);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class CreateFileW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_POINTER,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_LONG,
				LayoutUtils.C_LONG,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_LONG,
				LayoutUtils.C_LONG,
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("CreateFileW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * HANDLE CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
	 *}
	 */
	public static FunctionDescriptor CreateFileW$descriptor() {
		return CreateFileW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * HANDLE CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
	 *}
	 */
	public static MethodHandle CreateFileW$handle() {
		return CreateFileW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * HANDLE CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
	 *}
	 */
	public static MemorySegment CreateFileW(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, MemorySegment lpSecurityAttributes, int dwCreationDisposition, int dwFlagsAndAttributes, MemorySegment hTemplateFile) {
		var mh$ = CreateFileW.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("CreateFileW", lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
			}
			return (MemorySegment) mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class FindClose {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_BOOL,
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("FindClose"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL FindClose(HANDLE hFindFile)
	 *}
	 */
	public static FunctionDescriptor FindClose$descriptor() {
		return FindClose.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL FindClose(HANDLE hFindFile)
	 *}
	 */
	public static MethodHandle FindClose$handle() {
		return FindClose.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL FindClose(HANDLE hFindFile)
	 *}
	 */
	public static boolean FindClose(MemorySegment hFindFile) {
		var mh$ = FindClose.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("FindClose", hFindFile);
			}
			return (boolean) mh$.invokeExact(hFindFile);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class FindFirstFileExW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_POINTER,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_INT,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_INT,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("FindFirstFileExW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * HANDLE FindFirstFileExW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
	 *}
	 */
	public static FunctionDescriptor FindFirstFileExW$descriptor() {
		return FindFirstFileExW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * HANDLE FindFirstFileExW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
	 *}
	 */
	public static MethodHandle FindFirstFileExW$handle() {
		return FindFirstFileExW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * HANDLE FindFirstFileExW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
	 *}
	 */
	public static MemorySegment FindFirstFileExW(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFindFileData, int fSearchOp, MemorySegment lpSearchFilter, int dwAdditionalFlags) {
		var mh$ = FindFirstFileExW.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("FindFirstFileExW", lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);
			}
			return (MemorySegment) mh$.invokeExact(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class FindNextFileW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_BOOL,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("FindNextFileW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL FindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData)
	 *}
	 */
	public static FunctionDescriptor FindNextFileW$descriptor() {
		return FindNextFileW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL FindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData)
	 *}
	 */
	public static MethodHandle FindNextFileW$handle() {
		return FindNextFileW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL FindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData)
	 *}
	 */
	public static boolean FindNextFileW(MemorySegment hFindFile, MemorySegment lpFindFileData) {
		var mh$ = FindNextFileW.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("FindNextFileW", hFindFile, lpFindFileData);
			}
			return (boolean) mh$.invokeExact(hFindFile, lpFindFileData);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetFileSizeEx {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_BOOL,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("GetFileSizeEx"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize)
	 *}
	 */
	public static FunctionDescriptor GetFileSizeEx$descriptor() {
		return GetFileSizeEx.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize)
	 *}
	 */
	public static MethodHandle GetFileSizeEx$handle() {
		return GetFileSizeEx.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize)
	 *}
	 */
	public static boolean GetFileSizeEx(MemorySegment hFile, MemorySegment lpFileSize) {
		var mh$ = GetFileSizeEx.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("GetFileSizeEx", hFile, lpFileSize);
			}
			return (boolean) mh$.invokeExact(hFile, lpFileSize);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetFileType {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_LONG,
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("GetFileType"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * DWORD GetFileType(HANDLE hFile)
	 *}
	 */
	public static FunctionDescriptor GetFileType$descriptor() {
		return GetFileType.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * DWORD GetFileType(HANDLE hFile)
	 *}
	 */
	public static MethodHandle GetFileType$handle() {
		return GetFileType.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * DWORD GetFileType(HANDLE hFile)
	 *}
	 */
	public static int GetFileType(MemorySegment hFile) {
		var mh$ = GetFileType.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("GetFileType", hFile);
			}
			return (int) mh$.invokeExact(hFile);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class SetFilePointerEx {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_BOOL,
				LayoutUtils.C_POINTER,
				_LARGE_INTEGER.layout(),
				LayoutUtils.C_POINTER,
				LayoutUtils.C_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("SetFilePointerEx"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod)
	 *}
	 */
	public static FunctionDescriptor SetFilePointerEx$descriptor() {
		return SetFilePointerEx.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod)
	 *}
	 */
	public static MethodHandle SetFilePointerEx$handle() {
		return SetFilePointerEx.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod)
	 *}
	 */
	public static boolean SetFilePointerEx(MemorySegment hFile, MemorySegment liDistanceToMove, MemorySegment lpNewFilePointer, int dwMoveMethod) {
		var mh$ = SetFilePointerEx.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("SetFilePointerEx", hFile, liDistanceToMove, lpNewFilePointer, dwMoveMethod);
			}
			return (boolean) mh$.invokeExact(hFile, liDistanceToMove, lpNewFilePointer, dwMoveMethod);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class IsDebuggerPresent {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_BOOL);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("IsDebuggerPresent"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL IsDebuggerPresent()
	 *}
	 */
	public static FunctionDescriptor IsDebuggerPresent$descriptor() {
		return IsDebuggerPresent.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL IsDebuggerPresent()
	 *}
	 */
	public static MethodHandle IsDebuggerPresent$handle() {
		return IsDebuggerPresent.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL IsDebuggerPresent()
	 *}
	 */
	public static boolean IsDebuggerPresent() {
		var mh$ = IsDebuggerPresent.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("IsDebuggerPresent");
			}
			return (boolean) mh$.invokeExact();
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class OutputDebugStringW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("OutputDebugStringW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * void OutputDebugStringW(LPCWSTR lpOutputString)
	 *}
	 */
	public static FunctionDescriptor OutputDebugStringW$descriptor() {
		return OutputDebugStringW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * void OutputDebugStringW(LPCWSTR lpOutputString)
	 *}
	 */
	public static MethodHandle OutputDebugStringW$handle() {
		return OutputDebugStringW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * void OutputDebugStringW(LPCWSTR lpOutputString)
	 *}
	 */
	public static void OutputDebugStringW(MemorySegment lpOutputString) {
		var mh$ = OutputDebugStringW.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("OutputDebugStringW", lpOutputString);
			}
			mh$.invokeExact(lpOutputString);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class EncodePointer {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_POINTER,
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("EncodePointer"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * PVOID EncodePointer(PVOID Ptr)
	 *}
	 */
	public static FunctionDescriptor EncodePointer$descriptor() {
		return EncodePointer.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * PVOID EncodePointer(PVOID Ptr)
	 *}
	 */
	public static MethodHandle EncodePointer$handle() {
		return EncodePointer.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * PVOID EncodePointer(PVOID Ptr)
	 *}
	 */
	public static MemorySegment EncodePointer(MemorySegment Ptr) {
		var mh$ = EncodePointer.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("EncodePointer", Ptr);
			}
			return (MemorySegment) mh$.invokeExact(Ptr);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class CloseHandle {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_BOOL,
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("CloseHandle"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL CloseHandle(HANDLE hObject)
	 *}
	 */
	public static FunctionDescriptor CloseHandle$descriptor() {
		return CloseHandle.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL CloseHandle(HANDLE hObject)
	 *}
	 */
	public static MethodHandle CloseHandle$handle() {
		return CloseHandle.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL CloseHandle(HANDLE hObject)
	 *}
	 */
	public static boolean CloseHandle(MemorySegment hObject) {
		var mh$ = CloseHandle.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("CloseHandle", hObject);
			}
			return (boolean) mh$.invokeExact(hObject);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class RaiseException {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				LayoutUtils.C_LONG,
				LayoutUtils.C_LONG,
				LayoutUtils.C_LONG,
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("RaiseException"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * void RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)
	 *}
	 */
	public static FunctionDescriptor RaiseException$descriptor() {
		return RaiseException.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * void RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)
	 *}
	 */
	public static MethodHandle RaiseException$handle() {
		return RaiseException.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * void RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)
	 *}
	 */
	public static void RaiseException(int dwExceptionCode, int dwExceptionFlags, int nNumberOfArguments, MemorySegment lpArguments) {
		var mh$ = RaiseException.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("RaiseException", dwExceptionCode, dwExceptionFlags, nNumberOfArguments, lpArguments);
			}
			mh$.invokeExact(dwExceptionCode, dwExceptionFlags, nNumberOfArguments, lpArguments);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class UnhandledExceptionFilter {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_LONG,
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("UnhandledExceptionFilter"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * LONG UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
	 *}
	 */
	public static FunctionDescriptor UnhandledExceptionFilter$descriptor() {
		return UnhandledExceptionFilter.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * LONG UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
	 *}
	 */
	public static MethodHandle UnhandledExceptionFilter$handle() {
		return UnhandledExceptionFilter.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * LONG UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
	 *}
	 */
	public static int UnhandledExceptionFilter(MemorySegment ExceptionInfo) {
		var mh$ = UnhandledExceptionFilter.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("UnhandledExceptionFilter", ExceptionInfo);
			}
			return (int) mh$.invokeExact(ExceptionInfo);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class SetUnhandledExceptionFilter {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_POINTER,
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("SetUnhandledExceptionFilter"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
	 *}
	 */
	public static FunctionDescriptor SetUnhandledExceptionFilter$descriptor() {
		return SetUnhandledExceptionFilter.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
	 *}
	 */
	public static MethodHandle SetUnhandledExceptionFilter$handle() {
		return SetUnhandledExceptionFilter.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
	 *}
	 */
	public static MemorySegment SetUnhandledExceptionFilter(MemorySegment lpTopLevelExceptionFilter) {
		var mh$ = SetUnhandledExceptionFilter.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("SetUnhandledExceptionFilter", lpTopLevelExceptionFilter);
			}
			return (MemorySegment) mh$.invokeExact(lpTopLevelExceptionFilter);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetLastError {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_LONG);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("GetLastError"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * DWORD GetLastError()
	 *}
	 */
	public static FunctionDescriptor GetLastError$descriptor() {
		return GetLastError.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * DWORD GetLastError()
	 *}
	 */
	public static MethodHandle GetLastError$handle() {
		return GetLastError.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * DWORD GetLastError()
	 *}
	 */
	public static int GetLastError() {
		var mh$ = GetLastError.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("GetLastError");
			}
			return (int) mh$.invokeExact();
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class SetLastError {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				LayoutUtils.C_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("SetLastError"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * void SetLastError(DWORD dwErrCode)
	 *}
	 */
	public static FunctionDescriptor SetLastError$descriptor() {
		return SetLastError.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * void SetLastError(DWORD dwErrCode)
	 *}
	 */
	public static MethodHandle SetLastError$handle() {
		return SetLastError.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * void SetLastError(DWORD dwErrCode)
	 *}
	 */
	public static void SetLastError(int dwErrCode) {
		var mh$ = SetLastError.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("SetLastError", dwErrCode);
			}
			mh$.invokeExact(dwErrCode);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class FlsAlloc {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_LONG,
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("FlsAlloc"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * DWORD FlsAlloc(PFLS_CALLBACK_FUNCTION lpCallback)
	 *}
	 */
	public static FunctionDescriptor FlsAlloc$descriptor() {
		return FlsAlloc.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * DWORD FlsAlloc(PFLS_CALLBACK_FUNCTION lpCallback)
	 *}
	 */
	public static MethodHandle FlsAlloc$handle() {
		return FlsAlloc.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * DWORD FlsAlloc(PFLS_CALLBACK_FUNCTION lpCallback)
	 *}
	 */
	public static int FlsAlloc(MemorySegment lpCallback) {
		var mh$ = FlsAlloc.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("FlsAlloc", lpCallback);
			}
			return (int) mh$.invokeExact(lpCallback);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class FlsGetValue {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_POINTER,
				LayoutUtils.C_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("FlsGetValue"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * PVOID FlsGetValue(DWORD dwFlsIndex)
	 *}
	 */
	public static FunctionDescriptor FlsGetValue$descriptor() {
		return FlsGetValue.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * PVOID FlsGetValue(DWORD dwFlsIndex)
	 *}
	 */
	public static MethodHandle FlsGetValue$handle() {
		return FlsGetValue.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * PVOID FlsGetValue(DWORD dwFlsIndex)
	 *}
	 */
	public static MemorySegment FlsGetValue(int dwFlsIndex) {
		var mh$ = FlsGetValue.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("FlsGetValue", dwFlsIndex);
			}
			return (MemorySegment) mh$.invokeExact(dwFlsIndex);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class FlsSetValue {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_BOOL,
				LayoutUtils.C_LONG,
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("FlsSetValue"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL FlsSetValue(DWORD dwFlsIndex, PVOID lpFlsData)
	 *}
	 */
	public static FunctionDescriptor FlsSetValue$descriptor() {
		return FlsSetValue.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL FlsSetValue(DWORD dwFlsIndex, PVOID lpFlsData)
	 *}
	 */
	public static MethodHandle FlsSetValue$handle() {
		return FlsSetValue.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL FlsSetValue(DWORD dwFlsIndex, PVOID lpFlsData)
	 *}
	 */
	public static boolean FlsSetValue(int dwFlsIndex, MemorySegment lpFlsData) {
		var mh$ = FlsSetValue.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("FlsSetValue", dwFlsIndex, lpFlsData);
			}
			return (boolean) mh$.invokeExact(dwFlsIndex, lpFlsData);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class FlsFree {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_INT,
				LayoutUtils.C_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("FlsFree"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL FlsFree(DWORD dwFlsIndex)
	 *}
	 */
	public static FunctionDescriptor FlsFree$descriptor() {
		return FlsFree.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL FlsFree(DWORD dwFlsIndex)
	 *}
	 */
	public static MethodHandle FlsFree$handle() {
		return FlsFree.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL FlsFree(DWORD dwFlsIndex)
	 *}
	 */
	public static int FlsFree(int dwFlsIndex) {
		var mh$ = FlsFree.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("FlsFree", dwFlsIndex);
			}
			return (int) mh$.invokeExact(dwFlsIndex);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class QueryPerformanceCounter {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_BOOL,
				LARGE_INTEGER.POINTER$LAYOUT
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("QueryPerformanceCounter"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount)
	 *}
	 */
	public static FunctionDescriptor QueryPerformanceCounter$descriptor() {
		return QueryPerformanceCounter.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount)
	 *}
	 */
	public static MethodHandle QueryPerformanceCounter$handle() {
		return QueryPerformanceCounter.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount)
	 *}
	 */
	public static int QueryPerformanceCounter(MemorySegment lpPerformanceCount) {
		var mh$ = QueryPerformanceCounter.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("QueryPerformanceCounter", lpPerformanceCount);
			}
			return (int) mh$.invokeExact(lpPerformanceCount);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class ReleaseSRWLockExclusive {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("ReleaseSRWLockExclusive"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * void ReleaseSRWLockExclusive(PSRWLOCK SRWLock)
	 *}
	 */
	public static FunctionDescriptor ReleaseSRWLockExclusive$descriptor() {
		return ReleaseSRWLockExclusive.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * void ReleaseSRWLockExclusive(PSRWLOCK SRWLock)
	 *}
	 */
	public static MethodHandle ReleaseSRWLockExclusive$handle() {
		return ReleaseSRWLockExclusive.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * void ReleaseSRWLockExclusive(PSRWLOCK SRWLock)
	 *}
	 */
	public static void ReleaseSRWLockExclusive(MemorySegment SRWLock) {
		var mh$ = ReleaseSRWLockExclusive.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("ReleaseSRWLockExclusive", SRWLock);
			}
			mh$.invokeExact(SRWLock);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class AcquireSRWLockExclusive {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("AcquireSRWLockExclusive"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * void AcquireSRWLockExclusive(PSRWLOCK SRWLock)
	 *}
	 */
	public static FunctionDescriptor AcquireSRWLockExclusive$descriptor() {
		return AcquireSRWLockExclusive.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * void AcquireSRWLockExclusive(PSRWLOCK SRWLock)
	 *}
	 */
	public static MethodHandle AcquireSRWLockExclusive$handle() {
		return AcquireSRWLockExclusive.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * void AcquireSRWLockExclusive(PSRWLOCK SRWLock)
	 *}
	 */
	public static void AcquireSRWLockExclusive(MemorySegment SRWLock) {
		var mh$ = AcquireSRWLockExclusive.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("AcquireSRWLockExclusive", SRWLock);
			}
			mh$.invokeExact(SRWLock);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class EnterCriticalSection {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("EnterCriticalSection"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * void EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
	 *}
	 */
	public static FunctionDescriptor EnterCriticalSection$descriptor() {
		return EnterCriticalSection.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * void EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
	 *}
	 */
	public static MethodHandle EnterCriticalSection$handle() {
		return EnterCriticalSection.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * void EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
	 *}
	 */
	public static void EnterCriticalSection(MemorySegment lpCriticalSection) {
		var mh$ = EnterCriticalSection.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("EnterCriticalSection", lpCriticalSection);
			}
			mh$.invokeExact(lpCriticalSection);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class LeaveCriticalSection {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("LeaveCriticalSection"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * void LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
	 *}
	 */
	public static FunctionDescriptor LeaveCriticalSection$descriptor() {
		return LeaveCriticalSection.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * void LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
	 *}
	 */
	public static MethodHandle LeaveCriticalSection$handle() {
		return LeaveCriticalSection.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * void LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
	 *}
	 */
	public static void LeaveCriticalSection(MemorySegment lpCriticalSection) {
		var mh$ = LeaveCriticalSection.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("LeaveCriticalSection", lpCriticalSection);
			}
			mh$.invokeExact(lpCriticalSection);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class InitializeCriticalSectionAndSpinCount {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_INT,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("InitializeCriticalSectionAndSpinCount"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
	 *}
	 */
	public static FunctionDescriptor InitializeCriticalSectionAndSpinCount$descriptor() {
		return InitializeCriticalSectionAndSpinCount.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
	 *}
	 */
	public static MethodHandle InitializeCriticalSectionAndSpinCount$handle() {
		return InitializeCriticalSectionAndSpinCount.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
	 *}
	 */
	public static int InitializeCriticalSectionAndSpinCount(MemorySegment lpCriticalSection, int dwSpinCount) {
		var mh$ = InitializeCriticalSectionAndSpinCount.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("InitializeCriticalSectionAndSpinCount", lpCriticalSection, dwSpinCount);
			}
			return (int) mh$.invokeExact(lpCriticalSection, dwSpinCount);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class DeleteCriticalSection {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("DeleteCriticalSection"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * void DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
	 *}
	 */
	public static FunctionDescriptor DeleteCriticalSection$descriptor() {
		return DeleteCriticalSection.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * void DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
	 *}
	 */
	public static MethodHandle DeleteCriticalSection$handle() {
		return DeleteCriticalSection.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * void DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
	 *}
	 */
	public static void DeleteCriticalSection(MemorySegment lpCriticalSection) {
		var mh$ = DeleteCriticalSection.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("DeleteCriticalSection", lpCriticalSection);
			}
			mh$.invokeExact(lpCriticalSection);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class WakeAllConditionVariable {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("WakeAllConditionVariable"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * void WakeAllConditionVariable(PCONDITION_VARIABLE ConditionVariable)
	 *}
	 */
	public static FunctionDescriptor WakeAllConditionVariable$descriptor() {
		return WakeAllConditionVariable.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * void WakeAllConditionVariable(PCONDITION_VARIABLE ConditionVariable)
	 *}
	 */
	public static MethodHandle WakeAllConditionVariable$handle() {
		return WakeAllConditionVariable.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * void WakeAllConditionVariable(PCONDITION_VARIABLE ConditionVariable)
	 *}
	 */
	public static void WakeAllConditionVariable(MemorySegment ConditionVariable) {
		var mh$ = WakeAllConditionVariable.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("WakeAllConditionVariable", ConditionVariable);
			}
			mh$.invokeExact(ConditionVariable);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class SleepConditionVariableSRW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_INT,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_LONG,
				LayoutUtils.C_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("SleepConditionVariableSRW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL SleepConditionVariableSRW(PCONDITION_VARIABLE ConditionVariable, PSRWLOCK SRWLock, DWORD dwMilliseconds, ULONG Flags)
	 *}
	 */
	public static FunctionDescriptor SleepConditionVariableSRW$descriptor() {
		return SleepConditionVariableSRW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL SleepConditionVariableSRW(PCONDITION_VARIABLE ConditionVariable, PSRWLOCK SRWLock, DWORD dwMilliseconds, ULONG Flags)
	 *}
	 */
	public static MethodHandle SleepConditionVariableSRW$handle() {
		return SleepConditionVariableSRW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL SleepConditionVariableSRW(PCONDITION_VARIABLE ConditionVariable, PSRWLOCK SRWLock, DWORD dwMilliseconds, ULONG Flags)
	 *}
	 */
	public static int SleepConditionVariableSRW(MemorySegment ConditionVariable, MemorySegment SRWLock, int dwMilliseconds, int Flags) {
		var mh$ = SleepConditionVariableSRW.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("SleepConditionVariableSRW", ConditionVariable, SRWLock, dwMilliseconds, Flags);
			}
			return (int) mh$.invokeExact(ConditionVariable, SRWLock, dwMilliseconds, Flags);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class InitializeSListHead {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("InitializeSListHead"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * void InitializeSListHead(PSLIST_HEADER ListHead)
	 *}
	 */
	public static FunctionDescriptor InitializeSListHead$descriptor() {
		return InitializeSListHead.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * void InitializeSListHead(PSLIST_HEADER ListHead)
	 *}
	 */
	public static MethodHandle InitializeSListHead$handle() {
		return InitializeSListHead.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * void InitializeSListHead(PSLIST_HEADER ListHead)
	 *}
	 */
	public static void InitializeSListHead(MemorySegment ListHead) {
		var mh$ = InitializeSListHead.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("InitializeSListHead", ListHead);
			}
			mh$.invokeExact(ListHead);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class InterlockedFlushSList {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_POINTER,
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("InterlockedFlushSList"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * PSLIST_ENTRY InterlockedFlushSList(PSLIST_HEADER ListHead)
	 *}
	 */
	public static FunctionDescriptor InterlockedFlushSList$descriptor() {
		return InterlockedFlushSList.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * PSLIST_ENTRY InterlockedFlushSList(PSLIST_HEADER ListHead)
	 *}
	 */
	public static MethodHandle InterlockedFlushSList$handle() {
		return InterlockedFlushSList.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * PSLIST_ENTRY InterlockedFlushSList(PSLIST_HEADER ListHead)
	 *}
	 */
	public static MemorySegment InterlockedFlushSList(MemorySegment ListHead) {
		var mh$ = InterlockedFlushSList.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("InterlockedFlushSList", ListHead);
			}
			return (MemorySegment) mh$.invokeExact(ListHead);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetCurrentProcess {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_POINTER);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("GetCurrentProcess"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * HANDLE GetCurrentProcess()
	 *}
	 */
	public static FunctionDescriptor GetCurrentProcess$descriptor() {
		return GetCurrentProcess.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * HANDLE GetCurrentProcess()
	 *}
	 */
	public static MethodHandle GetCurrentProcess$handle() {
		return GetCurrentProcess.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * HANDLE GetCurrentProcess()
	 *}
	 */
	public static MemorySegment GetCurrentProcess() {
		var mh$ = GetCurrentProcess.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("GetCurrentProcess");
			}
			return (MemorySegment) mh$.invokeExact();
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class ExitProcess {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				LayoutUtils.C_INT
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("ExitProcess"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * void ExitProcess(UINT uExitCode)
	 *}
	 */
	public static FunctionDescriptor ExitProcess$descriptor() {
		return ExitProcess.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * void ExitProcess(UINT uExitCode)
	 *}
	 */
	public static MethodHandle ExitProcess$handle() {
		return ExitProcess.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * void ExitProcess(UINT uExitCode)
	 *}
	 */
	public static void ExitProcess(int uExitCode) {
		var mh$ = ExitProcess.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("ExitProcess", uExitCode);
			}
			mh$.invokeExact(uExitCode);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetCurrentThreadId {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_LONG);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("GetCurrentThreadId"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * DWORD GetCurrentThreadId()
	 *}
	 */
	public static FunctionDescriptor GetCurrentThreadId$descriptor() {
		return GetCurrentThreadId.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * DWORD GetCurrentThreadId()
	 *}
	 */
	public static MethodHandle GetCurrentThreadId$handle() {
		return GetCurrentThreadId.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * DWORD GetCurrentThreadId()
	 *}
	 */
	public static int GetCurrentThreadId() {
		var mh$ = GetCurrentThreadId.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("GetCurrentThreadId");
			}
			return (int) mh$.invokeExact();
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class TlsAlloc {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_LONG);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("TlsAlloc"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * DWORD TlsAlloc()
	 *}
	 */
	public static FunctionDescriptor TlsAlloc$descriptor() {
		return TlsAlloc.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * DWORD TlsAlloc()
	 *}
	 */
	public static MethodHandle TlsAlloc$handle() {
		return TlsAlloc.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * DWORD TlsAlloc()
	 *}
	 */
	public static int TlsAlloc() {
		var mh$ = TlsAlloc.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("TlsAlloc");
			}
			return (int) mh$.invokeExact();
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class TlsGetValue {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_POINTER,
				LayoutUtils.C_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("TlsGetValue"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * LPVOID TlsGetValue(DWORD dwTlsIndex)
	 *}
	 */
	public static FunctionDescriptor TlsGetValue$descriptor() {
		return TlsGetValue.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * LPVOID TlsGetValue(DWORD dwTlsIndex)
	 *}
	 */
	public static MethodHandle TlsGetValue$handle() {
		return TlsGetValue.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * LPVOID TlsGetValue(DWORD dwTlsIndex)
	 *}
	 */
	public static MemorySegment TlsGetValue(int dwTlsIndex) {
		var mh$ = TlsGetValue.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("TlsGetValue", dwTlsIndex);
			}
			return (MemorySegment) mh$.invokeExact(dwTlsIndex);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class TlsSetValue {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_INT,
				LayoutUtils.C_LONG,
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("TlsSetValue"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue)
	 *}
	 */
	public static FunctionDescriptor TlsSetValue$descriptor() {
		return TlsSetValue.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue)
	 *}
	 */
	public static MethodHandle TlsSetValue$handle() {
		return TlsSetValue.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue)
	 *}
	 */
	public static int TlsSetValue(int dwTlsIndex, MemorySegment lpTlsValue) {
		var mh$ = TlsSetValue.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("TlsSetValue", dwTlsIndex, lpTlsValue);
			}
			return (int) mh$.invokeExact(dwTlsIndex, lpTlsValue);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class TlsFree {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_INT,
				LayoutUtils.C_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("TlsFree"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL TlsFree(DWORD dwTlsIndex)
	 *}
	 */
	public static FunctionDescriptor TlsFree$descriptor() {
		return TlsFree.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL TlsFree(DWORD dwTlsIndex)
	 *}
	 */
	public static MethodHandle TlsFree$handle() {
		return TlsFree.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL TlsFree(DWORD dwTlsIndex)
	 *}
	 */
	public static int TlsFree(int dwTlsIndex) {
		var mh$ = TlsFree.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("TlsFree", dwTlsIndex);
			}
			return (int) mh$.invokeExact(dwTlsIndex);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetSystemTimeAsFileTime {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("GetSystemTimeAsFileTime"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * void GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
	 *}
	 */
	public static FunctionDescriptor GetSystemTimeAsFileTime$descriptor() {
		return GetSystemTimeAsFileTime.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * void GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
	 *}
	 */
	public static MethodHandle GetSystemTimeAsFileTime$handle() {
		return GetSystemTimeAsFileTime.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * void GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
	 *}
	 */
	public static void GetSystemTimeAsFileTime(MemorySegment lpSystemTimeAsFileTime) {
		var mh$ = GetSystemTimeAsFileTime.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("GetSystemTimeAsFileTime", lpSystemTimeAsFileTime);
			}
			mh$.invokeExact(lpSystemTimeAsFileTime);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetModuleFileNameW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.DWORD,
				LayoutUtils.C_POINTER,
				LayoutUtils.LPWSTR,
				LayoutUtils.DWORD
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("GetModuleFileNameW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * DWORD GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize)
	 *}
	 */
	public static FunctionDescriptor GetModuleFileNameW$descriptor() {
		return GetModuleFileNameW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * DWORD GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize)
	 *}
	 */
	public static MethodHandle GetModuleFileNameW$handle() {
		return GetModuleFileNameW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * DWORD GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize)
	 *}
	 */
	public static int GetModuleFileNameW(MemorySegment hModule, MemorySegment lpFilename, int nSize) {
		var mh$ = GetModuleFileNameW.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("GetModuleFileNameW", hModule, lpFilename, nSize);
			}
			return (int) mh$.invokeExact(hModule, lpFilename, nSize);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetModuleHandleA {
		private static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_POINTER,
				LayoutUtils.LPCSTR
		);
		
		private static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("GetModuleHandleA"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * HMODULE GetModuleHandleA(LPCSTR lpModuleName)
	 *}
	 */
	public static FunctionDescriptor GetModuleHandleA$descriptor() {
		return GetModuleHandleA.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * HMODULE GetModuleHandleA(LPCSTR lpModuleName)
	 *}
	 */
	public static MethodHandle GetModuleHandleA$handle() {
		return GetModuleHandleA.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * HMODULE GetModuleHandleA(LPCSTR lpModuleName)
	 *}
	 */
	public static MemorySegment GetModuleHandleA(MemorySegment lpModuleName) {
		var mh$ = GetModuleHandleA.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("GetModuleHandleA", lpModuleName);
			}
			return (MemorySegment) mh$.invokeExact(lpModuleName);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetModuleHandleExW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_BOOL,
				LayoutUtils.C_LONG,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("GetModuleHandleExW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL GetModuleHandleExW(DWORD dwFlags, LPCWSTR lpModuleName, HMODULE *phModule)
	 *}
	 */
	public static FunctionDescriptor GetModuleHandleExW$descriptor() {
		return GetModuleHandleExW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL GetModuleHandleExW(DWORD dwFlags, LPCWSTR lpModuleName, HMODULE *phModule)
	 *}
	 */
	public static MethodHandle GetModuleHandleExW$handle() {
		return GetModuleHandleExW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL GetModuleHandleExW(DWORD dwFlags, LPCWSTR lpModuleName, HMODULE *phModule)
	 *}
	 */
	public static boolean GetModuleHandleExW(int dwFlags, MemorySegment lpModuleName, MemorySegment phModule) {
		var mh$ = GetModuleHandleExW.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("GetModuleHandleExW", dwFlags, lpModuleName, phModule);
			}
			return (boolean) mh$.invokeExact(dwFlags, lpModuleName, phModule);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetMessageW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_BOOL,
				LayoutUtils.LPMSG,
				LayoutUtils.HWND,
				LayoutUtils.C_INT,
				LayoutUtils.C_INT
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("GetMessageW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL GetMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
	 *}
	 */
	public static FunctionDescriptor GetMessageW$descriptor() {
		return GetMessageW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL GetMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
	 *}
	 */
	public static MethodHandle GetMessageW$handle() {
		return GetMessageW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL GetMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
	 *}
	 */
	public static boolean GetMessageW(MemorySegment lpMsg, MemorySegment hWnd, int wMsgFilterMin, int wMsgFilterMax) {
		var mh$ = GetMessageW.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("GetMessageW", lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
			}
			return (boolean) mh$.invokeExact(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class TranslateMessage {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_BOOL,
				LayoutUtils.C_POINTER.withTargetLayout(MSG.layout())
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("TranslateMessage"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL TranslateMessage(const MSG *lpMsg)
	 *}
	 */
	public static FunctionDescriptor TranslateMessage$descriptor() {
		return TranslateMessage.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL TranslateMessage(const MSG *lpMsg)
	 *}
	 */
	public static MethodHandle TranslateMessage$handle() {
		return TranslateMessage.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL TranslateMessage(const MSG *lpMsg)
	 *}
	 */
	public static boolean TranslateMessage(MemorySegment lpMsg) {
		var mh$ = TranslateMessage.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("TranslateMessage", lpMsg);
			}
			return (boolean) mh$.invokeExact(lpMsg);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class DispatchMessageW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.LRESULT,
				LayoutUtils.C_POINTER.withTargetLayout(MSG.layout())
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("DispatchMessageW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * LRESULT DispatchMessageW(const MSG *lpMsg)
	 *}
	 */
	public static FunctionDescriptor DispatchMessageW$descriptor() {
		return DispatchMessageW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * LRESULT DispatchMessageW(const MSG *lpMsg)
	 *}
	 */
	public static MethodHandle DispatchMessageW$handle() {
		return DispatchMessageW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * LRESULT DispatchMessageW(const MSG *lpMsg)
	 *}
	 */
	public static long DispatchMessageW(MemorySegment lpMsg) {
		var mh$ = DispatchMessageW.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("DispatchMessageW", lpMsg);
			}
			return (long) mh$.invokeExact(lpMsg);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class PostMessageW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_BOOL,
				LayoutUtils.HWND,
				LayoutUtils.UINT,
				LayoutUtils.WPARAM,
				LayoutUtils.LPARAM
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("PostMessageW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
	 *}
	 */
	public static FunctionDescriptor PostMessageW$descriptor() {
		return PostMessageW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
	 *}
	 */
	public static MethodHandle PostMessageW$handle() {
		return PostMessageW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
	 *}
	 */
	public static boolean PostMessageW(MemorySegment hWnd, int Msg, long wParam, long lParam) {
		var mh$ = PostMessageW.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("PostMessageW", hWnd, Msg, wParam, lParam);
			}
			return (boolean) mh$.invokeExact(hWnd, Msg, wParam, lParam);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class DefWindowProcW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.LRESULT,
				LayoutUtils.HWND,
				LayoutUtils.C_INT,
				LayoutUtils.WPARAM,
				LayoutUtils.LPARAM
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("DefWindowProcW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * LRESULT DefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
	 *}
	 */
	public static FunctionDescriptor DefWindowProcW$descriptor() {
		return DefWindowProcW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * LRESULT DefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
	 *}
	 */
	public static MethodHandle DefWindowProcW$handle() {
		return DefWindowProcW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * LRESULT DefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
	 *}
	 */
	public static long DefWindowProcW(MemorySegment hWnd, int Msg, long wParam, long lParam) {
		var mh$ = DefWindowProcW.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("DefWindowProcW", hWnd, Msg, wParam, lParam);
			}
			return (long) mh$.invokeExact(hWnd, Msg, wParam, lParam);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class PostQuitMessage {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				LayoutUtils.C_INT
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("PostQuitMessage"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * void PostQuitMessage(int nExitCode)
	 *}
	 */
	public static FunctionDescriptor PostQuitMessage$descriptor() {
		return PostQuitMessage.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * void PostQuitMessage(int nExitCode)
	 *}
	 */
	public static MethodHandle PostQuitMessage$handle() {
		return PostQuitMessage.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * void PostQuitMessage(int nExitCode)
	 *}
	 */
	public static void PostQuitMessage(int nExitCode) {
		var mh$ = PostQuitMessage.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("PostQuitMessage", nExitCode);
			}
			mh$.invokeExact(nExitCode);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class RegisterClassExW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_SHORT,
				LayoutUtils.WNDCLASSEXW_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("RegisterClassExW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * ATOM RegisterClassExW(const WNDCLASSEXW *)
	 *}
	 */
	public static FunctionDescriptor RegisterClassExW$descriptor() {
		return RegisterClassExW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * ATOM RegisterClassExW(const WNDCLASSEXW *)
	 *}
	 */
	public static MethodHandle RegisterClassExW$handle() {
		return RegisterClassExW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * ATOM RegisterClassExW(const WNDCLASSEXW *)
	 *}
	 */
	public static short RegisterClassExW(MemorySegment x0) {
		var mh$ = RegisterClassExW.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("RegisterClassExW", x0);
			}
			return (short) mh$.invokeExact(x0);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class CreateWindowExW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_POINTER,
				LayoutUtils.DWORD,
				LayoutUtils.LPCWSTR,
				LayoutUtils.LPCWSTR,
				LayoutUtils.DWORD,
				LayoutUtils.C_INT,
				LayoutUtils.C_INT,
				LayoutUtils.C_INT,
				LayoutUtils.C_INT,
				LayoutUtils.HWND,
				LayoutUtils.HMENU,
				LayoutUtils.HINSTANCE,
				LayoutUtils.LPVOID
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("CreateWindowExW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * HWND CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
	 *}
	 */
	public static FunctionDescriptor CreateWindowExW$descriptor() {
		return CreateWindowExW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * HWND CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
	 *}
	 */
	public static MethodHandle CreateWindowExW$handle() {
		return CreateWindowExW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * HWND CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
	 *}
	 */
	public static MemorySegment CreateWindowExW(int dwExStyle, MemorySegment lpClassName, MemorySegment lpWindowName, int dwStyle, int X, int Y, int nWidth, int nHeight, MemorySegment hWndParent, MemorySegment hMenu, MemorySegment hInstance, MemorySegment lpParam) {
		var mh$ = CreateWindowExW.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("CreateWindowExW", dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
			}
			return (MemorySegment) mh$.invokeExact(dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class IsWindow {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_BOOL,
				LayoutUtils.HWND
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("IsWindow"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL IsWindow(HWND hWnd)
	 *}
	 */
	public static FunctionDescriptor IsWindow$descriptor() {
		return IsWindow.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL IsWindow(HWND hWnd)
	 *}
	 */
	public static MethodHandle IsWindow$handle() {
		return IsWindow.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL IsWindow(HWND hWnd)
	 *}
	 */
	public static int IsWindow(MemorySegment hWnd) {
		var mh$ = IsWindow.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("IsWindow", hWnd);
			}
			return (int) mh$.invokeExact(hWnd);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class DestroyWindow {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_BOOL,
				LayoutUtils.HWND
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("DestroyWindow"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL DestroyWindow(HWND hWnd)
	 *}
	 */
	public static FunctionDescriptor DestroyWindow$descriptor() {
		return DestroyWindow.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL DestroyWindow(HWND hWnd)
	 *}
	 */
	public static MethodHandle DestroyWindow$handle() {
		return DestroyWindow.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL DestroyWindow(HWND hWnd)
	 *}
	 */
	public static boolean DestroyWindow(MemorySegment hWnd) {
		var mh$ = DestroyWindow.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("DestroyWindow", hWnd);
			}
			return (boolean) mh$.invokeExact(hWnd);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class ShowWindow {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_BOOL,
				LayoutUtils.HWND,
				LayoutUtils.C_INT
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("ShowWindow"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL ShowWindow(HWND hWnd, int nCmdShow)
	 *}
	 */
	public static FunctionDescriptor ShowWindow$descriptor() {
		return ShowWindow.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL ShowWindow(HWND hWnd, int nCmdShow)
	 *}
	 */
	public static MethodHandle ShowWindow$handle() {
		return ShowWindow.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL ShowWindow(HWND hWnd, int nCmdShow)
	 *}
	 */
	public static boolean ShowWindow(MemorySegment hWnd, int nCmdShow) {
		var mh$ = ShowWindow.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("ShowWindow", hWnd, nCmdShow);
			}
			return (boolean) mh$.invokeExact(hWnd, nCmdShow);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class MoveWindow {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_BOOL,
				LayoutUtils.HWND,
				LayoutUtils.C_INT,
				LayoutUtils.C_INT,
				LayoutUtils.C_INT,
				LayoutUtils.C_INT,
				LayoutUtils.C_BOOL
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("MoveWindow"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
	 *}
	 */
	public static FunctionDescriptor MoveWindow$descriptor() {
		return MoveWindow.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
	 *}
	 */
	public static MethodHandle MoveWindow$handle() {
		return MoveWindow.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
	 *}
	 */
	public static int MoveWindow(MemorySegment hWnd, int X, int Y, int nWidth, int nHeight, int bRepaint) {
		var mh$ = MoveWindow.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("MoveWindow", hWnd, X, Y, nWidth, nHeight, bRepaint);
			}
			return (int) mh$.invokeExact(hWnd, X, Y, nWidth, nHeight, bRepaint);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class SetWindowPos {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_BOOL,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_INT,
				LayoutUtils.C_INT,
				LayoutUtils.C_INT,
				LayoutUtils.C_INT,
				LayoutUtils.C_INT
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("SetWindowPos"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags)
	 *}
	 */
	public static FunctionDescriptor SetWindowPos$descriptor() {
		return SetWindowPos.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags)
	 *}
	 */
	public static MethodHandle SetWindowPos$handle() {
		return SetWindowPos.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags)
	 *}
	 */
	public static int SetWindowPos(MemorySegment hWnd, MemorySegment hWndInsertAfter, int X, int Y, int cx, int cy, int uFlags) {
		var mh$ = SetWindowPos.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("SetWindowPos", hWnd, hWndInsertAfter, X, Y, cx, cy, uFlags);
			}
			return (int) mh$.invokeExact(hWnd, hWndInsertAfter, X, Y, cx, cy, uFlags);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class SetFocus {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.HWND,
				LayoutUtils.HWND
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("SetFocus"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * HWND SetFocus(HWND hWnd)
	 *}
	 */
	public static FunctionDescriptor SetFocus$descriptor() {
		return SetFocus.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * HWND SetFocus(HWND hWnd)
	 *}
	 */
	public static MethodHandle SetFocus$handle() {
		return SetFocus.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * HWND SetFocus(HWND hWnd)
	 *}
	 */
	public static MemorySegment SetFocus(MemorySegment hWnd) {
		var mh$ = SetFocus.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("SetFocus", hWnd);
			}
			return (MemorySegment) mh$.invokeExact(hWnd);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetSystemMetrics {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_INT,
				LayoutUtils.C_INT
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("GetSystemMetrics"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * int GetSystemMetrics(int nIndex)
	 *}
	 */
	public static FunctionDescriptor GetSystemMetrics$descriptor() {
		return GetSystemMetrics.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * int GetSystemMetrics(int nIndex)
	 *}
	 */
	public static MethodHandle GetSystemMetrics$handle() {
		return GetSystemMetrics.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * int GetSystemMetrics(int nIndex)
	 *}
	 */
	public static int GetSystemMetrics(int nIndex) {
		var mh$ = GetSystemMetrics.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("GetSystemMetrics", nIndex);
			}
			return (int) mh$.invokeExact(nIndex);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class UpdateWindow {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_BOOL,
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("UpdateWindow"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL UpdateWindow(HWND hWnd)
	 *}
	 */
	public static FunctionDescriptor UpdateWindow$descriptor() {
		return UpdateWindow.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL UpdateWindow(HWND hWnd)
	 *}
	 */
	public static MethodHandle UpdateWindow$handle() {
		return UpdateWindow.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL UpdateWindow(HWND hWnd)
	 *}
	 */
	public static boolean UpdateWindow(MemorySegment hWnd) {
		var mh$ = UpdateWindow.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("UpdateWindow", hWnd);
			}
			return (boolean) mh$.invokeExact(hWnd);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class SetWindowTextW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_BOOL,
				LayoutUtils.HWND,
				LayoutUtils.LPCWSTR
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("SetWindowTextW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL SetWindowTextW(HWND hWnd, LPCWSTR lpString)
	 *}
	 */
	public static FunctionDescriptor SetWindowTextW$descriptor() {
		return SetWindowTextW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL SetWindowTextW(HWND hWnd, LPCWSTR lpString)
	 *}
	 */
	public static MethodHandle SetWindowTextW$handle() {
		return SetWindowTextW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL SetWindowTextW(HWND hWnd, LPCWSTR lpString)
	 *}
	 */
	public static int SetWindowTextW(MemorySegment hWnd, MemorySegment lpString) {
		var mh$ = SetWindowTextW.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("SetWindowTextW", hWnd, lpString);
			}
			return (int) mh$.invokeExact(hWnd, lpString);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetClientRect {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_BOOL,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("GetClientRect"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL GetClientRect(HWND hWnd, LPRECT lpRect)
	 *}
	 */
	public static FunctionDescriptor GetClientRect$descriptor() {
		return GetClientRect.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL GetClientRect(HWND hWnd, LPRECT lpRect)
	 *}
	 */
	public static MethodHandle GetClientRect$handle() {
		return GetClientRect.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL GetClientRect(HWND hWnd, LPRECT lpRect)
	 *}
	 */
	public static boolean GetClientRect(MemorySegment hWnd, MemorySegment lpRect) {
		var mh$ = GetClientRect.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("GetClientRect", hWnd, lpRect);
			}
			return (boolean) mh$.invokeExact(hWnd, lpRect);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class AdjustWindowRect {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_BOOL,
				LayoutUtils.LPRECT,
				LayoutUtils.DWORD,
				LayoutUtils.C_BOOL
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("AdjustWindowRect"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL AdjustWindowRect(LPRECT lpRect, DWORD dwStyle, BOOL bMenu)
	 *}
	 */
	public static FunctionDescriptor AdjustWindowRect$descriptor() {
		return AdjustWindowRect.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL AdjustWindowRect(LPRECT lpRect, DWORD dwStyle, BOOL bMenu)
	 *}
	 */
	public static MethodHandle AdjustWindowRect$handle() {
		return AdjustWindowRect.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL AdjustWindowRect(LPRECT lpRect, DWORD dwStyle, BOOL bMenu)
	 *}
	 */
	public static boolean AdjustWindowRect(MemorySegment lpRect, int dwStyle, boolean bMenu) {
		var mh$ = AdjustWindowRect.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("AdjustWindowRect", lpRect, dwStyle, bMenu);
			}
			return (boolean) mh$.invokeExact(lpRect, dwStyle, bMenu);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetWindowLongPtrW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_POINTER,
				LayoutUtils.HWND,
				LayoutUtils.C_INT
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("GetWindowLongPtrW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * LONG_PTR GetWindowLongPtrW(HWND hWnd, int nIndex)
	 *}
	 */
	public static FunctionDescriptor GetWindowLongPtrW$descriptor() {
		return GetWindowLongPtrW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * LONG_PTR GetWindowLongPtrW(HWND hWnd, int nIndex)
	 *}
	 */
	public static MethodHandle GetWindowLongPtrW$handle() {
		return GetWindowLongPtrW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * LONG_PTR GetWindowLongPtrW(HWND hWnd, int nIndex)
	 *}
	 */
	public static long GetWindowLongPtrW(MemorySegment hWnd, int nIndex) {
		var mh$ = GetWindowLongPtrW.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("GetWindowLongPtrW", hWnd, nIndex);
			}
			return (long) mh$.invokeExact(hWnd, nIndex);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class SetWindowLongPtrW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_LONG_LONG,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_INT,
				LayoutUtils.C_LONG_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("SetWindowLongPtrW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * LONG_PTR SetWindowLongPtrW(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
	 *}
	 */
	public static FunctionDescriptor SetWindowLongPtrW$descriptor() {
		return SetWindowLongPtrW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * LONG_PTR SetWindowLongPtrW(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
	 *}
	 */
	public static MethodHandle SetWindowLongPtrW$handle() {
		return SetWindowLongPtrW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * LONG_PTR SetWindowLongPtrW(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
	 *}
	 */
	public static long SetWindowLongPtrW(MemorySegment hWnd, int nIndex, long dwNewLong) {
		var mh$ = SetWindowLongPtrW.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("SetWindowLongPtrW", hWnd, nIndex, dwNewLong);
			}
			return (long) mh$.invokeExact(hWnd, nIndex, dwNewLong);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetParent {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_POINTER,
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("GetParent"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * HWND GetParent(HWND hWnd)
	 *}
	 */
	public static FunctionDescriptor GetParent$descriptor() {
		return GetParent.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * HWND GetParent(HWND hWnd)
	 *}
	 */
	public static MethodHandle GetParent$handle() {
		return GetParent.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * HWND GetParent(HWND hWnd)
	 *}
	 */
	public static MemorySegment GetParent(MemorySegment hWnd) {
		var mh$ = GetParent.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("GetParent", hWnd);
			}
			return (MemorySegment) mh$.invokeExact(hWnd);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class LoadImageW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_POINTER,
				LayoutUtils.HINSTANCE,
				LayoutUtils.LPCWSTR,
				LayoutUtils.UINT,
				LayoutUtils.C_INT,
				LayoutUtils.C_INT,
				LayoutUtils.UINT
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("LoadImageW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * HANDLE LoadImageW(HINSTANCE hInst, LPCWSTR name, UINT type, int cx, int cy, UINT fuLoad)
	 *}
	 */
	public static FunctionDescriptor LoadImageW$descriptor() {
		return LoadImageW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * HANDLE LoadImageW(HINSTANCE hInst, LPCWSTR name, UINT type, int cx, int cy, UINT fuLoad)
	 *}
	 */
	public static MethodHandle LoadImageW$handle() {
		return LoadImageW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * HANDLE LoadImageW(HINSTANCE hInst, LPCWSTR name, UINT type, int cx, int cy, UINT fuLoad)
	 *}
	 */
	public static MemorySegment LoadImageW(MemorySegment hInst, MemorySegment name, int type, int cx, int cy, int fuLoad) {
		var mh$ = LoadImageW.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("LoadImageW", hInst, name, type, cx, cy, fuLoad);
			}
			return (MemorySegment) mh$.invokeExact(hInst, name, type, cx, cy, fuLoad);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class DestroyIcon {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_BOOL,
				LayoutUtils.HICON
		);
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("DestroyIcon"),
				DESC);
	}
	public static FunctionDescriptor DestroyIcon$descriptor() {
		return DestroyIcon.DESC;
	}
	public static MethodHandle DestroyIconW$handle() {
		return DestroyIcon.HANDLE;
	}
	public static boolean DestroyIcon(MemorySegment hIcon) {
		var mh$ = DestroyIcon.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("DestroyIcon", hIcon);
			}
			return (boolean) mh$.invokeExact(hIcon);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	private static class SetProcessDpiAwarenessContext {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_BOOL,
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("SetProcessDpiAwarenessContext"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
	 *}
	 */
	public static FunctionDescriptor SetProcessDpiAwarenessContext$descriptor() {
		return SetProcessDpiAwarenessContext.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
	 *}
	 */
	public static MethodHandle SetProcessDpiAwarenessContext$handle() {
		return SetProcessDpiAwarenessContext.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
	 *}
	 */
	public static boolean SetProcessDpiAwarenessContext(MemorySegment value) {
		var mh$ = SetProcessDpiAwarenessContext.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("SetProcessDpiAwarenessContext", value);
			}
			return (boolean) mh$.invokeExact(value);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class MultiByteToWideChar {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_INT,
				LayoutUtils.C_INT,
				LayoutUtils.C_LONG,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_INT,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_INT
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("MultiByteToWideChar"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * int MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar)
	 *}
	 */
	public static FunctionDescriptor MultiByteToWideChar$descriptor() {
		return MultiByteToWideChar.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * int MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar)
	 *}
	 */
	public static MethodHandle MultiByteToWideChar$handle() {
		return MultiByteToWideChar.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * int MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar)
	 *}
	 */
	public static int MultiByteToWideChar(int CodePage, int dwFlags, MemorySegment lpMultiByteStr, int cbMultiByte, MemorySegment lpWideCharStr, int cchWideChar) {
		var mh$ = MultiByteToWideChar.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("MultiByteToWideChar", CodePage, dwFlags, lpMultiByteStr, cbMultiByte, lpWideCharStr, cchWideChar);
			}
			return (int) mh$.invokeExact(CodePage, dwFlags, lpMultiByteStr, cbMultiByte, lpWideCharStr, cchWideChar);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class WideCharToMultiByte {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_INT,
				LayoutUtils.C_INT,
				LayoutUtils.C_LONG,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_INT,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_INT,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("WideCharToMultiByte"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * int WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar)
	 *}
	 */
	public static FunctionDescriptor WideCharToMultiByte$descriptor() {
		return WideCharToMultiByte.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * int WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar)
	 *}
	 */
	public static MethodHandle WideCharToMultiByte$handle() {
		return WideCharToMultiByte.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * int WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar)
	 *}
	 */
	public static int WideCharToMultiByte(int CodePage, int dwFlags, MemorySegment lpWideCharStr, int cchWideChar, MemorySegment lpMultiByteStr, int cbMultiByte, MemorySegment lpDefaultChar, MemorySegment lpUsedDefaultChar) {
		var mh$ = WideCharToMultiByte.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("WideCharToMultiByte", CodePage, dwFlags, lpWideCharStr, cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar);
			}
			return (int) mh$.invokeExact(CodePage, dwFlags, lpWideCharStr, cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class IsValidCodePage {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_INT,
				LayoutUtils.C_INT
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("IsValidCodePage"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL IsValidCodePage(UINT CodePage)
	 *}
	 */
	public static FunctionDescriptor IsValidCodePage$descriptor() {
		return IsValidCodePage.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL IsValidCodePage(UINT CodePage)
	 *}
	 */
	public static MethodHandle IsValidCodePage$handle() {
		return IsValidCodePage.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL IsValidCodePage(UINT CodePage)
	 *}
	 */
	public static int IsValidCodePage(int CodePage) {
		var mh$ = IsValidCodePage.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("IsValidCodePage", CodePage);
			}
			return (int) mh$.invokeExact(CodePage);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetACP {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_INT);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("GetACP"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * UINT GetACP()
	 *}
	 */
	public static FunctionDescriptor GetACP$descriptor() {
		return GetACP.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * UINT GetACP()
	 *}
	 */
	public static MethodHandle GetACP$handle() {
		return GetACP.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * UINT GetACP()
	 *}
	 */
	public static int GetACP() {
		var mh$ = GetACP.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("GetACP");
			}
			return (int) mh$.invokeExact();
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class LCMapStringW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_INT,
				LayoutUtils.C_LONG,
				LayoutUtils.C_LONG,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_INT,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_INT
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("LCMapStringW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * int LCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
	 *}
	 */
	public static FunctionDescriptor LCMapStringW$descriptor() {
		return LCMapStringW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * int LCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
	 *}
	 */
	public static MethodHandle LCMapStringW$handle() {
		return LCMapStringW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * int LCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
	 *}
	 */
	public static int LCMapStringW(int Locale, int dwMapFlags, MemorySegment lpSrcStr, int cchSrc, MemorySegment lpDestStr, int cchDest) {
		var mh$ = LCMapStringW.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("LCMapStringW", Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
			}
			return (int) mh$.invokeExact(Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetConsoleOutputCP {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_INT);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("GetConsoleOutputCP"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * UINT GetConsoleOutputCP()
	 *}
	 */
	public static FunctionDescriptor GetConsoleOutputCP$descriptor() {
		return GetConsoleOutputCP.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * UINT GetConsoleOutputCP()
	 *}
	 */
	public static MethodHandle GetConsoleOutputCP$handle() {
		return GetConsoleOutputCP.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * UINT GetConsoleOutputCP()
	 *}
	 */
	public static int GetConsoleOutputCP() {
		var mh$ = GetConsoleOutputCP.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("GetConsoleOutputCP");
			}
			return (int) mh$.invokeExact();
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetConsoleMode {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_BOOL,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("GetConsoleMode"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode)
	 *}
	 */
	public static FunctionDescriptor GetConsoleMode$descriptor() {
		return GetConsoleMode.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode)
	 *}
	 */
	public static MethodHandle GetConsoleMode$handle() {
		return GetConsoleMode.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode)
	 *}
	 */
	public static boolean GetConsoleMode(MemorySegment hConsoleHandle, MemorySegment lpMode) {
		var mh$ = GetConsoleMode.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("GetConsoleMode", hConsoleHandle, lpMode);
			}
			return (boolean) mh$.invokeExact(hConsoleHandle, lpMode);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class WriteConsoleW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_INT,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_LONG,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("WriteConsoleW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL WriteConsoleW(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
	 *}
	 */
	public static FunctionDescriptor WriteConsoleW$descriptor() {
		return WriteConsoleW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL WriteConsoleW(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
	 *}
	 */
	public static MethodHandle WriteConsoleW$handle() {
		return WriteConsoleW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL WriteConsoleW(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
	 *}
	 */
	public static int WriteConsoleW(MemorySegment hConsoleOutput, MemorySegment lpBuffer, int nNumberOfCharsToWrite, MemorySegment lpNumberOfCharsWritten, MemorySegment lpReserved) {
		var mh$ = WriteConsoleW.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("WriteConsoleW", hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved);
			}
			return (int) mh$.invokeExact(hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetFileVersionInfoSizeW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_LONG,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("GetFileVersionInfoSizeW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * DWORD GetFileVersionInfoSizeW(LPCWSTR lptstrFilename, LPDWORD lpdwHandle)
	 *}
	 */
	public static FunctionDescriptor GetFileVersionInfoSizeW$descriptor() {
		return GetFileVersionInfoSizeW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * DWORD GetFileVersionInfoSizeW(LPCWSTR lptstrFilename, LPDWORD lpdwHandle)
	 *}
	 */
	public static MethodHandle GetFileVersionInfoSizeW$handle() {
		return GetFileVersionInfoSizeW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * DWORD GetFileVersionInfoSizeW(LPCWSTR lptstrFilename, LPDWORD lpdwHandle)
	 *}
	 */
	public static int GetFileVersionInfoSizeW(MemorySegment lptstrFilename, MemorySegment lpdwHandle) {
		var mh$ = GetFileVersionInfoSizeW.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("GetFileVersionInfoSizeW", lptstrFilename, lpdwHandle);
			}
			return (int) mh$.invokeExact(lptstrFilename, lpdwHandle);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetFileVersionInfoW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_INT,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_LONG,
				LayoutUtils.C_LONG,
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("GetFileVersionInfoW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL GetFileVersionInfoW(LPCWSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
	 *}
	 */
	public static FunctionDescriptor GetFileVersionInfoW$descriptor() {
		return GetFileVersionInfoW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL GetFileVersionInfoW(LPCWSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
	 *}
	 */
	public static MethodHandle GetFileVersionInfoW$handle() {
		return GetFileVersionInfoW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL GetFileVersionInfoW(LPCWSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
	 *}
	 */
	public static int GetFileVersionInfoW(MemorySegment lptstrFilename, int dwHandle, int dwLen, MemorySegment lpData) {
		var mh$ = GetFileVersionInfoW.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("GetFileVersionInfoW", lptstrFilename, dwHandle, dwLen, lpData);
			}
			return (int) mh$.invokeExact(lptstrFilename, dwHandle, dwLen, lpData);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class VerQueryValueW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_INT,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("VerQueryValueW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL VerQueryValueW(LPCVOID pBlock, LPCWSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
	 *}
	 */
	public static FunctionDescriptor VerQueryValueW$descriptor() {
		return VerQueryValueW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL VerQueryValueW(LPCVOID pBlock, LPCWSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
	 *}
	 */
	public static MethodHandle VerQueryValueW$handle() {
		return VerQueryValueW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL VerQueryValueW(LPCVOID pBlock, LPCWSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
	 *}
	 */
	public static int VerQueryValueW(MemorySegment pBlock, MemorySegment lpSubBlock, MemorySegment lplpBuffer, MemorySegment puLen) {
		var mh$ = VerQueryValueW.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("VerQueryValueW", pBlock, lpSubBlock, lplpBuffer, puLen);
			}
			return (int) mh$.invokeExact(pBlock, lpSubBlock, lplpBuffer, puLen);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class RegCloseKey {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_LONG,
				LayoutUtils.HKEY
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("RegCloseKey"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * LSTATUS RegCloseKey(HKEY hKey)
	 *}
	 */
	public static FunctionDescriptor RegCloseKey$descriptor() {
		return RegCloseKey.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * LSTATUS RegCloseKey(HKEY hKey)
	 *}
	 */
	public static MethodHandle RegCloseKey$handle() {
		return RegCloseKey.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * LSTATUS RegCloseKey(HKEY hKey)
	 *}
	 */
	public static int RegCloseKey(MemorySegment hKey) {
		var mh$ = RegCloseKey.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("RegCloseKey", hKey);
			}
			return (int) mh$.invokeExact(hKey);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class RegOpenKeyExW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_LONG,
				LayoutUtils.HKEY,
				LayoutUtils.LPCWSTR,
				LayoutUtils.DWORD,
				LayoutUtils.C_LONG,
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("RegOpenKeyExW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * LSTATUS RegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
	 *}
	 */
	public static FunctionDescriptor RegOpenKeyExW$descriptor() {
		return RegOpenKeyExW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * LSTATUS RegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
	 *}
	 */
	public static MethodHandle RegOpenKeyExW$handle() {
		return RegOpenKeyExW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * LSTATUS RegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
	 *}
	 */
	public static int RegOpenKeyExW(MemorySegment hKey, MemorySegment lpSubKey, int ulOptions, int samDesired, MemorySegment phkResult) {
		var mh$ = RegOpenKeyExW.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("RegOpenKeyExW", hKey, lpSubKey, ulOptions, samDesired, phkResult);
			}
			return (int) mh$.invokeExact(hKey, lpSubKey, ulOptions, samDesired, phkResult);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class RegQueryValueExW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_LONG,
				LayoutUtils.HKEY,
				LayoutUtils.LPCWSTR,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("RegQueryValueExW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * LSTATUS RegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
	 *}
	 */
	public static FunctionDescriptor RegQueryValueExW$descriptor() {
		return RegQueryValueExW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * LSTATUS RegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
	 *}
	 */
	public static MethodHandle RegQueryValueExW$handle() {
		return RegQueryValueExW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * LSTATUS RegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
	 *}
	 */
	public static int RegQueryValueExW(MemorySegment hKey, MemorySegment lpValueName, MemorySegment lpReserved, MemorySegment lpType, MemorySegment lpData, MemorySegment lpcbData) {
		var mh$ = RegQueryValueExW.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("RegQueryValueExW", hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);
			}
			return (int) mh$.invokeExact(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class CoUninitialize {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid();
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("CoUninitialize"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * extern void CoUninitialize()
	 *}
	 */
	public static FunctionDescriptor CoUninitialize$descriptor() {
		return CoUninitialize.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * extern void CoUninitialize()
	 *}
	 */
	public static MethodHandle CoUninitialize$handle() {
		return CoUninitialize.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * extern void CoUninitialize()
	 *}
	 */
	public static void CoUninitialize() {
		var mh$ = CoUninitialize.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("CoUninitialize");
			}
			mh$.invokeExact();
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class CoInitializeEx {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_LONG,
				LayoutUtils.C_POINTER,
				LayoutUtils.C_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("CoInitializeEx"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * extern HRESULT CoInitializeEx(LPVOID pvReserved, DWORD dwCoInit)
	 *}
	 */
	public static FunctionDescriptor CoInitializeEx$descriptor() {
		return CoInitializeEx.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * extern HRESULT CoInitializeEx(LPVOID pvReserved, DWORD dwCoInit)
	 *}
	 */
	public static MethodHandle CoInitializeEx$handle() {
		return CoInitializeEx.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * extern HRESULT CoInitializeEx(LPVOID pvReserved, DWORD dwCoInit)
	 *}
	 */
	public static int CoInitializeEx(MemorySegment pvReserved, int dwCoInit) {
		var mh$ = CoInitializeEx.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("CoInitializeEx", pvReserved, dwCoInit);
			}
			return (int) mh$.invokeExact(pvReserved, dwCoInit);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class CoTaskMemAlloc {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				LayoutUtils.C_POINTER,
				LayoutUtils.C_LONG_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("CoTaskMemAlloc"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * extern LPVOID CoTaskMemAlloc(SIZE_T cb)
	 *}
	 */
	public static FunctionDescriptor CoTaskMemAlloc$descriptor() {
		return CoTaskMemAlloc.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * extern LPVOID CoTaskMemAlloc(SIZE_T cb)
	 *}
	 */
	public static MethodHandle CoTaskMemAlloc$handle() {
		return CoTaskMemAlloc.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * extern LPVOID CoTaskMemAlloc(SIZE_T cb)
	 *}
	 */
	public static MemorySegment CoTaskMemAlloc(long cb) {
		var mh$ = CoTaskMemAlloc.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("CoTaskMemAlloc", cb);
			}
			return (MemorySegment) mh$.invokeExact(cb);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class CoTaskMemFree {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				LayoutUtils.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				FFMUtils.SYMBOL_LOOKUP.findOrThrow("CoTaskMemFree"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * extern void CoTaskMemFree(LPVOID pv)
	 *}
	 */
	public static FunctionDescriptor CoTaskMemFree$descriptor() {
		return CoTaskMemFree.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * extern void CoTaskMemFree(LPVOID pv)
	 *}
	 */
	public static MethodHandle CoTaskMemFree$handle() {
		return CoTaskMemFree.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * extern void CoTaskMemFree(LPVOID pv)
	 *}
	 */
	public static void CoTaskMemFree(MemorySegment pv) {
		var mh$ = CoTaskMemFree.HANDLE;
		try {
			if ( FFMUtils.TRACE_DOWNCALLS ) {
				FFMUtils.traceDowncall("CoTaskMemFree", pv);
			}
			mh$.invokeExact(pv);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	@SuppressWarnings({"SpellCheckingInspection", "PointlessBitwiseExpression"})
	public static final int
			WM_DESTROY = 0x0002,
			WM_SIZE = 0x0005,
			WM_CLOSE = 0x0010,
			WM_QUIT = 0x0012,
			WM_SIZING = 0x0214,
			WM_USER = 0x0400,
			WS_OVERLAPPEDWINDOW = 0x00000000 | 0x00C00000 | 0x00080000 | 0x00040000 | 0x00020000 | 0x00010000;
	@SuppressWarnings("SpellCheckingInspection")
	public static final int CW_USEDEFAULT = 0x80000000;
	public static final int SW_SHOW = 5;
	public static final int IMAGE_ICON = 1;
	/**
	 * Loads the standalone image from the file specified by name (icon, cursor, or bitmap file).
	 */
	public static final int LR_LOADFROMFILE = 0x00000010;
}
