// Generated by jextract

package org.jextract;

import java.lang.foreign.AddressLayout;
import java.lang.foreign.Arena;
import java.lang.foreign.FunctionDescriptor;
import java.lang.foreign.GroupLayout;
import java.lang.foreign.Linker;
import java.lang.foreign.MemoryLayout;
import java.lang.foreign.MemorySegment;
import java.lang.foreign.PaddingLayout;
import java.lang.foreign.SequenceLayout;
import java.lang.foreign.StructLayout;
import java.lang.foreign.SymbolLookup;
import java.lang.foreign.ValueLayout;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.util.Arrays;
import java.util.stream.Collectors;

import static java.lang.foreign.ValueLayout.OfBoolean;
import static java.lang.foreign.ValueLayout.OfByte;
import static java.lang.foreign.ValueLayout.OfDouble;
import static java.lang.foreign.ValueLayout.OfFloat;
import static java.lang.foreign.ValueLayout.OfInt;
import static java.lang.foreign.ValueLayout.OfLong;
import static java.lang.foreign.ValueLayout.OfShort;

public class Windows {
	
	Windows() {
		// Should not be called directly
	}
	
	static final Arena LIBRARY_ARENA = Arena.ofAuto();
	static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");
	
	static void traceDowncall(String name, Object... args) {
		String traceArgs = Arrays.stream(args)
				                   .map(Object::toString)
				                   .collect(Collectors.joining(", "));
		System.out.printf("%s(%s)\n", name, traceArgs);
	}
	
	@SuppressWarnings("SpellCheckingInspection")
	static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
		try {
			return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
		} catch (ReflectiveOperationException ex) {
			throw new AssertionError(ex);
		}
	}
	
	static MemoryLayout align(MemoryLayout layout, long align) {
		return switch (layout) {
			case PaddingLayout p -> p;
			case ValueLayout v -> v.withByteAlignment(align);
			case GroupLayout g -> {
				MemoryLayout[] alignedMembers = g.memberLayouts().stream()
						                                .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
				yield g instanceof StructLayout ?
						      MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
			}
			case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
		};
	}
	
	static final SymbolLookup SYMBOL_LOOKUP;
	public static final ValueLayout.OfBoolean C_BOOL;
	public static final ValueLayout.OfByte C_CHAR;
	public static final ValueLayout.OfShort C_SHORT;
	public static final ValueLayout.OfInt C_INT;
	public static final ValueLayout.OfLong C_LONG_LONG;
	public static final ValueLayout.OfFloat C_FLOAT;
	public static final ValueLayout.OfDouble C_DOUBLE;
	public static final AddressLayout C_POINTER;
	public static final ValueLayout.OfInt C_LONG;
	public static final ValueLayout.OfDouble C_LONG_DOUBLE;
	
	static {
		final var nativeLinker = Linker.nativeLinker();
		SYMBOL_LOOKUP = SymbolLookup.libraryLookup(System.mapLibraryName("USER32"), LIBRARY_ARENA)
				                .or(SymbolLookup.libraryLookup(System.mapLibraryName("ADVAPI32"), LIBRARY_ARENA))
				                .or(SymbolLookup.libraryLookup(System.mapLibraryName("ole32"), LIBRARY_ARENA))
				                .or(SymbolLookup.libraryLookup(System.mapLibraryName("SHELL32"), LIBRARY_ARENA))
				                .or(SymbolLookup.libraryLookup(System.mapLibraryName("SHLWAPI"), LIBRARY_ARENA))
				                .or(SymbolLookup.libraryLookup(System.mapLibraryName("VERSION"), LIBRARY_ARENA))
				                .or(SymbolLookup.libraryLookup(System.mapLibraryName("KERNEL32"), LIBRARY_ARENA))
				                .or(SymbolLookup.loaderLookup())
				                .or(nativeLinker.defaultLookup());
		final var canonicalLayouts = nativeLinker.canonicalLayouts();
		C_BOOL = (OfBoolean) canonicalLayouts.get("bool");
		C_CHAR = (OfByte) canonicalLayouts.get("char");
		C_SHORT = (OfShort) canonicalLayouts.get("short");
		C_INT = (OfInt) canonicalLayouts.get("int");
		C_LONG_LONG = (OfLong) canonicalLayouts.get("long long");
		C_FLOAT = (OfFloat) canonicalLayouts.get("float");
		C_DOUBLE = (OfDouble) canonicalLayouts.get("double");
		C_POINTER = ((AddressLayout) canonicalLayouts.get("void*"))
				            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, C_CHAR));
		C_LONG = (OfInt) canonicalLayouts.get("long");
		C_LONG_DOUBLE = (OfDouble) canonicalLayouts.get("double");
	}
	
	/**
	 * {@snippet lang = c:
	 * typedef unsigned long DWORD
	 *}
	 */
	public static final OfInt DWORD = Windows.C_LONG;
	/**
	 * {@snippet lang = c:
	 * typedef void *LPVOID
	 *}
	 */
	public static final AddressLayout LPVOID = Windows.C_POINTER;
	/**
	 * {@snippet lang = c:
	 * typedef long long LONG_PTR
	 *}
	 */
	public static final OfLong LONG_PTR = Windows.C_LONG_LONG;
	/**
	 * {@snippet lang = c:
	 * typedef long LONG
	 *}
	 */
	public static final OfInt LONG = Windows.C_LONG;
	/**
	 * {@snippet lang = c:
	 * typedef WCHAR *LPWSTR
	 *}
	 */
	@SuppressWarnings("SpellCheckingInspection")
	public static final AddressLayout LPWSTR = Windows.C_POINTER;
	/**
	 * {@snippet lang = c:
	 * typedef const WCHAR *LPCWSTR
	 *}
	 */
	@SuppressWarnings("SpellCheckingInspection")
	public static final AddressLayout LPCWSTR = Windows.C_POINTER;
	/**
	 * {@snippet lang = c:
	 * typedef const WCHAR *PCWSTR
	 *}
	 */
	@SuppressWarnings("SpellCheckingInspection")
	public static final AddressLayout PCWSTR = Windows.C_POINTER;
	/**
	 * {@snippet lang = c:
	 * typedef const CHAR *LPCSTR
	 *}
	 */
	public static final AddressLayout LPCSTR = Windows.C_POINTER;
	/**
	 * {@snippet lang = c:
	 * typedef LARGE_INTEGER *PLARGE_INTEGER
	 *}
	 */
	public static final AddressLayout PLARGE_INTEGER = Windows.C_POINTER;
	
	private static class RtlCaptureContext {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("RtlCaptureContext"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * void RtlCaptureContext(PCONTEXT ContextRecord)
	 *}
	 */
	public static FunctionDescriptor RtlCaptureContext$descriptor() {
		return RtlCaptureContext.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * void RtlCaptureContext(PCONTEXT ContextRecord)
	 *}
	 */
	public static MethodHandle RtlCaptureContext$handle() {
		return RtlCaptureContext.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * void RtlCaptureContext(PCONTEXT ContextRecord)
	 *}
	 */
	public static void RtlCaptureContext(MemorySegment ContextRecord) {
		var mh$ = RtlCaptureContext.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("RtlCaptureContext", ContextRecord);
			}
			mh$.invokeExact(ContextRecord);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class RtlLookupFunctionEntry {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_POINTER,
				Windows.C_LONG_LONG,
				Windows.C_POINTER,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("RtlLookupFunctionEntry"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * PRUNTIME_FUNCTION RtlLookupFunctionEntry(DWORD64 ControlPc, PDWORD64 ImageBase, PUNWIND_HISTORY_TABLE HistoryTable)
	 *}
	 */
	public static FunctionDescriptor RtlLookupFunctionEntry$descriptor() {
		return RtlLookupFunctionEntry.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * PRUNTIME_FUNCTION RtlLookupFunctionEntry(DWORD64 ControlPc, PDWORD64 ImageBase, PUNWIND_HISTORY_TABLE HistoryTable)
	 *}
	 */
	public static MethodHandle RtlLookupFunctionEntry$handle() {
		return RtlLookupFunctionEntry.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * PRUNTIME_FUNCTION RtlLookupFunctionEntry(DWORD64 ControlPc, PDWORD64 ImageBase, PUNWIND_HISTORY_TABLE HistoryTable)
	 *}
	 */
	public static MemorySegment RtlLookupFunctionEntry(long ControlPc, MemorySegment ImageBase, MemorySegment HistoryTable) {
		var mh$ = RtlLookupFunctionEntry.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("RtlLookupFunctionEntry", ControlPc, ImageBase, HistoryTable);
			}
			return (MemorySegment) mh$.invokeExact(ControlPc, ImageBase, HistoryTable);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class RtlUnwindEx {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				Windows.C_POINTER,
				Windows.C_POINTER,
				Windows.C_POINTER,
				Windows.C_POINTER,
				Windows.C_POINTER,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("RtlUnwindEx"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * void RtlUnwindEx(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue, PCONTEXT ContextRecord, PUNWIND_HISTORY_TABLE HistoryTable)
	 *}
	 */
	public static FunctionDescriptor RtlUnwindEx$descriptor() {
		return RtlUnwindEx.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * void RtlUnwindEx(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue, PCONTEXT ContextRecord, PUNWIND_HISTORY_TABLE HistoryTable)
	 *}
	 */
	public static MethodHandle RtlUnwindEx$handle() {
		return RtlUnwindEx.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * void RtlUnwindEx(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue, PCONTEXT ContextRecord, PUNWIND_HISTORY_TABLE HistoryTable)
	 *}
	 */
	public static void RtlUnwindEx(MemorySegment TargetFrame, MemorySegment TargetIp, MemorySegment ExceptionRecord, MemorySegment ReturnValue, MemorySegment ContextRecord, MemorySegment HistoryTable) {
		var mh$ = RtlUnwindEx.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("RtlUnwindEx", TargetFrame, TargetIp, ExceptionRecord, ReturnValue, ContextRecord, HistoryTable);
			}
			mh$.invokeExact(TargetFrame, TargetIp, ExceptionRecord, ReturnValue, ContextRecord, HistoryTable);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class RtlVirtualUnwind {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_POINTER,
				Windows.C_LONG,
				Windows.C_LONG_LONG,
				Windows.C_LONG_LONG,
				Windows.C_POINTER,
				Windows.C_POINTER,
				Windows.C_POINTER,
				Windows.C_POINTER,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("RtlVirtualUnwind"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * PEXCEPTION_ROUTINE RtlVirtualUnwind(DWORD HandlerType, DWORD64 ImageBase, DWORD64 ControlPc, PRUNTIME_FUNCTION FunctionEntry, PCONTEXT ContextRecord, PVOID *HandlerData, PDWORD64 EstablisherFrame, PKNONVOLATILE_CONTEXT_POINTERS ContextPointers)
	 *}
	 */
	public static FunctionDescriptor RtlVirtualUnwind$descriptor() {
		return RtlVirtualUnwind.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * PEXCEPTION_ROUTINE RtlVirtualUnwind(DWORD HandlerType, DWORD64 ImageBase, DWORD64 ControlPc, PRUNTIME_FUNCTION FunctionEntry, PCONTEXT ContextRecord, PVOID *HandlerData, PDWORD64 EstablisherFrame, PKNONVOLATILE_CONTEXT_POINTERS ContextPointers)
	 *}
	 */
	public static MethodHandle RtlVirtualUnwind$handle() {
		return RtlVirtualUnwind.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * PEXCEPTION_ROUTINE RtlVirtualUnwind(DWORD HandlerType, DWORD64 ImageBase, DWORD64 ControlPc, PRUNTIME_FUNCTION FunctionEntry, PCONTEXT ContextRecord, PVOID *HandlerData, PDWORD64 EstablisherFrame, PKNONVOLATILE_CONTEXT_POINTERS ContextPointers)
	 *}
	 */
	public static MemorySegment RtlVirtualUnwind(int HandlerType, long ImageBase, long ControlPc, MemorySegment FunctionEntry, MemorySegment ContextRecord, MemorySegment HandlerData, MemorySegment EstablisherFrame, MemorySegment ContextPointers) {
		var mh$ = RtlVirtualUnwind.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("RtlVirtualUnwind", HandlerType, ImageBase, ControlPc, FunctionEntry, ContextRecord, HandlerData, EstablisherFrame, ContextPointers);
			}
			return (MemorySegment) mh$.invokeExact(HandlerType, ImageBase, ControlPc, FunctionEntry, ContextRecord, HandlerData, EstablisherFrame, ContextPointers);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class RtlPcToFileHeader {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_POINTER,
				Windows.C_POINTER,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("RtlPcToFileHeader"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * PVOID RtlPcToFileHeader(PVOID PcValue, PVOID *BaseOfImage)
	 *}
	 */
	public static FunctionDescriptor RtlPcToFileHeader$descriptor() {
		return RtlPcToFileHeader.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * PVOID RtlPcToFileHeader(PVOID PcValue, PVOID *BaseOfImage)
	 *}
	 */
	public static MethodHandle RtlPcToFileHeader$handle() {
		return RtlPcToFileHeader.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * PVOID RtlPcToFileHeader(PVOID PcValue, PVOID *BaseOfImage)
	 *}
	 */
	public static MemorySegment RtlPcToFileHeader(MemorySegment PcValue, MemorySegment BaseOfImage) {
		var mh$ = RtlPcToFileHeader.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("RtlPcToFileHeader", PcValue, BaseOfImage);
			}
			return (MemorySegment) mh$.invokeExact(PcValue, BaseOfImage);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	/**
	 * {@snippet lang = c:
	 * typedef UINT_PTR WPARAM
	 *}
	 */
	public static final OfLong WPARAM = Windows.C_LONG_LONG;
	/**
	 * {@snippet lang = c:
	 * typedef LONG_PTR LPARAM
	 *}
	 */
	public static final OfLong LPARAM = Windows.C_LONG_LONG;
	/**
	 * {@snippet lang = c:
	 * typedef LONG_PTR LRESULT
	 *}
	 */
	public static final OfLong LRESULT = Windows.C_LONG_LONG;
	/**
	 * {@snippet lang = c:
	 * typedef struct HKEY__ {
	 *     int unused;
	 * } *HKEY
	 *}
	 */
	public static final AddressLayout HKEY = Windows.C_POINTER;
	/**
	 * {@snippet lang = c:
	 * typedef struct HINSTANCE__ {
	 *     int unused;
	 * } *HINSTANCE
	 *}
	 */
	public static final AddressLayout HINSTANCE = Windows.C_POINTER;
	/**
	 * {@snippet lang = c:
	 * typedef struct HWND__ {
	 *     int unused;
	 * } *HWND
	 *}
	 */
	public static final AddressLayout HWND = Windows.C_POINTER;
	/**
	 * {@snippet lang = c:
	 * typedef struct HBRUSH__ {
	 *     int unused;
	 * } *HBRUSH
	 *}
	 */
	public static final AddressLayout HBRUSH = Windows.C_POINTER;
	/**
	 * {@snippet lang = c:
	 * typedef struct HICON__ {
	 *     int unused;
	 * } *HICON
	 *}
	 */
	public static final AddressLayout HICON = Windows.C_POINTER;
	/**
	 * {@snippet lang = c:
	 * typedef struct HMENU__ {
	 *     int unused;
	 * } *HMENU
	 *}
	 */
	public static final AddressLayout HMENU = Windows.C_POINTER;
	/**
	 * {@snippet lang = c:
	 * typedef HICON HCURSOR
	 *}
	 */
	public static final AddressLayout HCURSOR = Windows.C_POINTER;
	/**
	 * {@snippet lang = c:
	 * typedef struct tagRECT {
	 *     LONG left;
	 *     LONG top;
	 *     LONG right;
	 *     LONG bottom;
	 * } *LPRECT
	 *}
	 */
	public static final AddressLayout LPRECT = Windows.C_POINTER;
	
	private static class GetStdHandle {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_POINTER,
				Windows.C_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("GetStdHandle"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * HANDLE GetStdHandle(DWORD nStdHandle)
	 *}
	 */
	public static FunctionDescriptor GetStdHandle$descriptor() {
		return GetStdHandle.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * HANDLE GetStdHandle(DWORD nStdHandle)
	 *}
	 */
	public static MethodHandle GetStdHandle$handle() {
		return GetStdHandle.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * HANDLE GetStdHandle(DWORD nStdHandle)
	 *}
	 */
	public static MemorySegment GetStdHandle(int nStdHandle) {
		var mh$ = GetStdHandle.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("GetStdHandle", nStdHandle);
			}
			return (MemorySegment) mh$.invokeExact(nStdHandle);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class SetStdHandle {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_BOOL,
				Windows.C_LONG,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("SetStdHandle"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL SetStdHandle(DWORD nStdHandle, HANDLE hHandle)
	 *}
	 */
	public static FunctionDescriptor SetStdHandle$descriptor() {
		return SetStdHandle.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL SetStdHandle(DWORD nStdHandle, HANDLE hHandle)
	 *}
	 */
	public static MethodHandle SetStdHandle$handle() {
		return SetStdHandle.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL SetStdHandle(DWORD nStdHandle, HANDLE hHandle)
	 *}
	 */
	public static boolean SetStdHandle(int nStdHandle, MemorySegment hHandle) {
		var mh$ = SetStdHandle.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("SetStdHandle", nStdHandle, hHandle);
			}
			return (boolean) mh$.invokeExact(nStdHandle, hHandle);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class CreateFileW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_POINTER,
				Windows.C_POINTER,
				Windows.C_LONG,
				Windows.C_LONG,
				Windows.C_POINTER,
				Windows.C_LONG,
				Windows.C_LONG,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("CreateFileW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * HANDLE CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
	 *}
	 */
	public static FunctionDescriptor CreateFileW$descriptor() {
		return CreateFileW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * HANDLE CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
	 *}
	 */
	public static MethodHandle CreateFileW$handle() {
		return CreateFileW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * HANDLE CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
	 *}
	 */
	public static MemorySegment CreateFileW(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, MemorySegment lpSecurityAttributes, int dwCreationDisposition, int dwFlagsAndAttributes, MemorySegment hTemplateFile) {
		var mh$ = CreateFileW.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("CreateFileW", lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
			}
			return (MemorySegment) mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class FindClose {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_BOOL,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("FindClose"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL FindClose(HANDLE hFindFile)
	 *}
	 */
	public static FunctionDescriptor FindClose$descriptor() {
		return FindClose.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL FindClose(HANDLE hFindFile)
	 *}
	 */
	public static MethodHandle FindClose$handle() {
		return FindClose.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL FindClose(HANDLE hFindFile)
	 *}
	 */
	public static boolean FindClose(MemorySegment hFindFile) {
		var mh$ = FindClose.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("FindClose", hFindFile);
			}
			return (boolean) mh$.invokeExact(hFindFile);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class FindFirstFileExW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_POINTER,
				Windows.C_POINTER,
				Windows.C_INT,
				Windows.C_POINTER,
				Windows.C_INT,
				Windows.C_POINTER,
				Windows.C_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("FindFirstFileExW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * HANDLE FindFirstFileExW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
	 *}
	 */
	public static FunctionDescriptor FindFirstFileExW$descriptor() {
		return FindFirstFileExW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * HANDLE FindFirstFileExW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
	 *}
	 */
	public static MethodHandle FindFirstFileExW$handle() {
		return FindFirstFileExW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * HANDLE FindFirstFileExW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
	 *}
	 */
	public static MemorySegment FindFirstFileExW(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFindFileData, int fSearchOp, MemorySegment lpSearchFilter, int dwAdditionalFlags) {
		var mh$ = FindFirstFileExW.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("FindFirstFileExW", lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);
			}
			return (MemorySegment) mh$.invokeExact(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class FindNextFileW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_BOOL,
				Windows.C_POINTER,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("FindNextFileW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL FindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData)
	 *}
	 */
	public static FunctionDescriptor FindNextFileW$descriptor() {
		return FindNextFileW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL FindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData)
	 *}
	 */
	public static MethodHandle FindNextFileW$handle() {
		return FindNextFileW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL FindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData)
	 *}
	 */
	public static boolean FindNextFileW(MemorySegment hFindFile, MemorySegment lpFindFileData) {
		var mh$ = FindNextFileW.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("FindNextFileW", hFindFile, lpFindFileData);
			}
			return (boolean) mh$.invokeExact(hFindFile, lpFindFileData);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetFileSizeEx {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_BOOL,
				Windows.C_POINTER,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("GetFileSizeEx"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize)
	 *}
	 */
	public static FunctionDescriptor GetFileSizeEx$descriptor() {
		return GetFileSizeEx.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize)
	 *}
	 */
	public static MethodHandle GetFileSizeEx$handle() {
		return GetFileSizeEx.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize)
	 *}
	 */
	public static boolean GetFileSizeEx(MemorySegment hFile, MemorySegment lpFileSize) {
		var mh$ = GetFileSizeEx.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("GetFileSizeEx", hFile, lpFileSize);
			}
			return (boolean) mh$.invokeExact(hFile, lpFileSize);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetFileType {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_LONG,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("GetFileType"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * DWORD GetFileType(HANDLE hFile)
	 *}
	 */
	public static FunctionDescriptor GetFileType$descriptor() {
		return GetFileType.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * DWORD GetFileType(HANDLE hFile)
	 *}
	 */
	public static MethodHandle GetFileType$handle() {
		return GetFileType.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * DWORD GetFileType(HANDLE hFile)
	 *}
	 */
	public static int GetFileType(MemorySegment hFile) {
		var mh$ = GetFileType.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("GetFileType", hFile);
			}
			return (int) mh$.invokeExact(hFile);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class SetFilePointerEx {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_BOOL,
				Windows.C_POINTER,
				_LARGE_INTEGER.layout(),
				Windows.C_POINTER,
				Windows.C_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("SetFilePointerEx"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod)
	 *}
	 */
	public static FunctionDescriptor SetFilePointerEx$descriptor() {
		return SetFilePointerEx.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod)
	 *}
	 */
	public static MethodHandle SetFilePointerEx$handle() {
		return SetFilePointerEx.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod)
	 *}
	 */
	public static boolean SetFilePointerEx(MemorySegment hFile, MemorySegment liDistanceToMove, MemorySegment lpNewFilePointer, int dwMoveMethod) {
		var mh$ = SetFilePointerEx.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("SetFilePointerEx", hFile, liDistanceToMove, lpNewFilePointer, dwMoveMethod);
			}
			return (boolean) mh$.invokeExact(hFile, liDistanceToMove, lpNewFilePointer, dwMoveMethod);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class IsDebuggerPresent {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_BOOL);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("IsDebuggerPresent"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL IsDebuggerPresent()
	 *}
	 */
	public static FunctionDescriptor IsDebuggerPresent$descriptor() {
		return IsDebuggerPresent.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL IsDebuggerPresent()
	 *}
	 */
	public static MethodHandle IsDebuggerPresent$handle() {
		return IsDebuggerPresent.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL IsDebuggerPresent()
	 *}
	 */
	public static boolean IsDebuggerPresent() {
		var mh$ = IsDebuggerPresent.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("IsDebuggerPresent");
			}
			return (boolean) mh$.invokeExact();
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class OutputDebugStringW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("OutputDebugStringW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * void OutputDebugStringW(LPCWSTR lpOutputString)
	 *}
	 */
	public static FunctionDescriptor OutputDebugStringW$descriptor() {
		return OutputDebugStringW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * void OutputDebugStringW(LPCWSTR lpOutputString)
	 *}
	 */
	public static MethodHandle OutputDebugStringW$handle() {
		return OutputDebugStringW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * void OutputDebugStringW(LPCWSTR lpOutputString)
	 *}
	 */
	public static void OutputDebugStringW(MemorySegment lpOutputString) {
		var mh$ = OutputDebugStringW.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("OutputDebugStringW", lpOutputString);
			}
			mh$.invokeExact(lpOutputString);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class EncodePointer {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_POINTER,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("EncodePointer"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * PVOID EncodePointer(PVOID Ptr)
	 *}
	 */
	public static FunctionDescriptor EncodePointer$descriptor() {
		return EncodePointer.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * PVOID EncodePointer(PVOID Ptr)
	 *}
	 */
	public static MethodHandle EncodePointer$handle() {
		return EncodePointer.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * PVOID EncodePointer(PVOID Ptr)
	 *}
	 */
	public static MemorySegment EncodePointer(MemorySegment Ptr) {
		var mh$ = EncodePointer.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("EncodePointer", Ptr);
			}
			return (MemorySegment) mh$.invokeExact(Ptr);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class CloseHandle {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_BOOL,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("CloseHandle"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL CloseHandle(HANDLE hObject)
	 *}
	 */
	public static FunctionDescriptor CloseHandle$descriptor() {
		return CloseHandle.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL CloseHandle(HANDLE hObject)
	 *}
	 */
	public static MethodHandle CloseHandle$handle() {
		return CloseHandle.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL CloseHandle(HANDLE hObject)
	 *}
	 */
	public static boolean CloseHandle(MemorySegment hObject) {
		var mh$ = CloseHandle.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("CloseHandle", hObject);
			}
			return (boolean) mh$.invokeExact(hObject);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class RaiseException {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				Windows.C_LONG,
				Windows.C_LONG,
				Windows.C_LONG,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("RaiseException"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * void RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)
	 *}
	 */
	public static FunctionDescriptor RaiseException$descriptor() {
		return RaiseException.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * void RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)
	 *}
	 */
	public static MethodHandle RaiseException$handle() {
		return RaiseException.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * void RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)
	 *}
	 */
	public static void RaiseException(int dwExceptionCode, int dwExceptionFlags, int nNumberOfArguments, MemorySegment lpArguments) {
		var mh$ = RaiseException.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("RaiseException", dwExceptionCode, dwExceptionFlags, nNumberOfArguments, lpArguments);
			}
			mh$.invokeExact(dwExceptionCode, dwExceptionFlags, nNumberOfArguments, lpArguments);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class UnhandledExceptionFilter {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_LONG,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("UnhandledExceptionFilter"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * LONG UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
	 *}
	 */
	public static FunctionDescriptor UnhandledExceptionFilter$descriptor() {
		return UnhandledExceptionFilter.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * LONG UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
	 *}
	 */
	public static MethodHandle UnhandledExceptionFilter$handle() {
		return UnhandledExceptionFilter.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * LONG UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
	 *}
	 */
	public static int UnhandledExceptionFilter(MemorySegment ExceptionInfo) {
		var mh$ = UnhandledExceptionFilter.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("UnhandledExceptionFilter", ExceptionInfo);
			}
			return (int) mh$.invokeExact(ExceptionInfo);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class SetUnhandledExceptionFilter {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_POINTER,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("SetUnhandledExceptionFilter"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
	 *}
	 */
	public static FunctionDescriptor SetUnhandledExceptionFilter$descriptor() {
		return SetUnhandledExceptionFilter.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
	 *}
	 */
	public static MethodHandle SetUnhandledExceptionFilter$handle() {
		return SetUnhandledExceptionFilter.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
	 *}
	 */
	public static MemorySegment SetUnhandledExceptionFilter(MemorySegment lpTopLevelExceptionFilter) {
		var mh$ = SetUnhandledExceptionFilter.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("SetUnhandledExceptionFilter", lpTopLevelExceptionFilter);
			}
			return (MemorySegment) mh$.invokeExact(lpTopLevelExceptionFilter);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetLastError {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_LONG);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("GetLastError"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * DWORD GetLastError()
	 *}
	 */
	public static FunctionDescriptor GetLastError$descriptor() {
		return GetLastError.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * DWORD GetLastError()
	 *}
	 */
	public static MethodHandle GetLastError$handle() {
		return GetLastError.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * DWORD GetLastError()
	 *}
	 */
	public static int GetLastError() {
		var mh$ = GetLastError.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("GetLastError");
			}
			return (int) mh$.invokeExact();
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class SetLastError {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				Windows.C_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("SetLastError"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * void SetLastError(DWORD dwErrCode)
	 *}
	 */
	public static FunctionDescriptor SetLastError$descriptor() {
		return SetLastError.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * void SetLastError(DWORD dwErrCode)
	 *}
	 */
	public static MethodHandle SetLastError$handle() {
		return SetLastError.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * void SetLastError(DWORD dwErrCode)
	 *}
	 */
	public static void SetLastError(int dwErrCode) {
		var mh$ = SetLastError.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("SetLastError", dwErrCode);
			}
			mh$.invokeExact(dwErrCode);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class FlsAlloc {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_LONG,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("FlsAlloc"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * DWORD FlsAlloc(PFLS_CALLBACK_FUNCTION lpCallback)
	 *}
	 */
	public static FunctionDescriptor FlsAlloc$descriptor() {
		return FlsAlloc.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * DWORD FlsAlloc(PFLS_CALLBACK_FUNCTION lpCallback)
	 *}
	 */
	public static MethodHandle FlsAlloc$handle() {
		return FlsAlloc.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * DWORD FlsAlloc(PFLS_CALLBACK_FUNCTION lpCallback)
	 *}
	 */
	public static int FlsAlloc(MemorySegment lpCallback) {
		var mh$ = FlsAlloc.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("FlsAlloc", lpCallback);
			}
			return (int) mh$.invokeExact(lpCallback);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class FlsGetValue {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_POINTER,
				Windows.C_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("FlsGetValue"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * PVOID FlsGetValue(DWORD dwFlsIndex)
	 *}
	 */
	public static FunctionDescriptor FlsGetValue$descriptor() {
		return FlsGetValue.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * PVOID FlsGetValue(DWORD dwFlsIndex)
	 *}
	 */
	public static MethodHandle FlsGetValue$handle() {
		return FlsGetValue.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * PVOID FlsGetValue(DWORD dwFlsIndex)
	 *}
	 */
	public static MemorySegment FlsGetValue(int dwFlsIndex) {
		var mh$ = FlsGetValue.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("FlsGetValue", dwFlsIndex);
			}
			return (MemorySegment) mh$.invokeExact(dwFlsIndex);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class FlsSetValue {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_BOOL,
				Windows.C_LONG,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("FlsSetValue"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL FlsSetValue(DWORD dwFlsIndex, PVOID lpFlsData)
	 *}
	 */
	public static FunctionDescriptor FlsSetValue$descriptor() {
		return FlsSetValue.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL FlsSetValue(DWORD dwFlsIndex, PVOID lpFlsData)
	 *}
	 */
	public static MethodHandle FlsSetValue$handle() {
		return FlsSetValue.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL FlsSetValue(DWORD dwFlsIndex, PVOID lpFlsData)
	 *}
	 */
	public static boolean FlsSetValue(int dwFlsIndex, MemorySegment lpFlsData) {
		var mh$ = FlsSetValue.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("FlsSetValue", dwFlsIndex, lpFlsData);
			}
			return (boolean) mh$.invokeExact(dwFlsIndex, lpFlsData);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class FlsFree {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_INT,
				Windows.C_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("FlsFree"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL FlsFree(DWORD dwFlsIndex)
	 *}
	 */
	public static FunctionDescriptor FlsFree$descriptor() {
		return FlsFree.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL FlsFree(DWORD dwFlsIndex)
	 *}
	 */
	public static MethodHandle FlsFree$handle() {
		return FlsFree.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL FlsFree(DWORD dwFlsIndex)
	 *}
	 */
	public static int FlsFree(int dwFlsIndex) {
		var mh$ = FlsFree.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("FlsFree", dwFlsIndex);
			}
			return (int) mh$.invokeExact(dwFlsIndex);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class QueryPerformanceCounter {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_INT,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("QueryPerformanceCounter"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount)
	 *}
	 */
	public static FunctionDescriptor QueryPerformanceCounter$descriptor() {
		return QueryPerformanceCounter.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount)
	 *}
	 */
	public static MethodHandle QueryPerformanceCounter$handle() {
		return QueryPerformanceCounter.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount)
	 *}
	 */
	public static int QueryPerformanceCounter(MemorySegment lpPerformanceCount) {
		var mh$ = QueryPerformanceCounter.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("QueryPerformanceCounter", lpPerformanceCount);
			}
			return (int) mh$.invokeExact(lpPerformanceCount);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class ReleaseSRWLockExclusive {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("ReleaseSRWLockExclusive"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * void ReleaseSRWLockExclusive(PSRWLOCK SRWLock)
	 *}
	 */
	public static FunctionDescriptor ReleaseSRWLockExclusive$descriptor() {
		return ReleaseSRWLockExclusive.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * void ReleaseSRWLockExclusive(PSRWLOCK SRWLock)
	 *}
	 */
	public static MethodHandle ReleaseSRWLockExclusive$handle() {
		return ReleaseSRWLockExclusive.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * void ReleaseSRWLockExclusive(PSRWLOCK SRWLock)
	 *}
	 */
	public static void ReleaseSRWLockExclusive(MemorySegment SRWLock) {
		var mh$ = ReleaseSRWLockExclusive.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("ReleaseSRWLockExclusive", SRWLock);
			}
			mh$.invokeExact(SRWLock);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class AcquireSRWLockExclusive {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("AcquireSRWLockExclusive"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * void AcquireSRWLockExclusive(PSRWLOCK SRWLock)
	 *}
	 */
	public static FunctionDescriptor AcquireSRWLockExclusive$descriptor() {
		return AcquireSRWLockExclusive.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * void AcquireSRWLockExclusive(PSRWLOCK SRWLock)
	 *}
	 */
	public static MethodHandle AcquireSRWLockExclusive$handle() {
		return AcquireSRWLockExclusive.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * void AcquireSRWLockExclusive(PSRWLOCK SRWLock)
	 *}
	 */
	public static void AcquireSRWLockExclusive(MemorySegment SRWLock) {
		var mh$ = AcquireSRWLockExclusive.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("AcquireSRWLockExclusive", SRWLock);
			}
			mh$.invokeExact(SRWLock);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class EnterCriticalSection {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("EnterCriticalSection"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * void EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
	 *}
	 */
	public static FunctionDescriptor EnterCriticalSection$descriptor() {
		return EnterCriticalSection.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * void EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
	 *}
	 */
	public static MethodHandle EnterCriticalSection$handle() {
		return EnterCriticalSection.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * void EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
	 *}
	 */
	public static void EnterCriticalSection(MemorySegment lpCriticalSection) {
		var mh$ = EnterCriticalSection.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("EnterCriticalSection", lpCriticalSection);
			}
			mh$.invokeExact(lpCriticalSection);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class LeaveCriticalSection {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("LeaveCriticalSection"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * void LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
	 *}
	 */
	public static FunctionDescriptor LeaveCriticalSection$descriptor() {
		return LeaveCriticalSection.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * void LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
	 *}
	 */
	public static MethodHandle LeaveCriticalSection$handle() {
		return LeaveCriticalSection.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * void LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
	 *}
	 */
	public static void LeaveCriticalSection(MemorySegment lpCriticalSection) {
		var mh$ = LeaveCriticalSection.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("LeaveCriticalSection", lpCriticalSection);
			}
			mh$.invokeExact(lpCriticalSection);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class InitializeCriticalSectionAndSpinCount {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_INT,
				Windows.C_POINTER,
				Windows.C_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("InitializeCriticalSectionAndSpinCount"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
	 *}
	 */
	public static FunctionDescriptor InitializeCriticalSectionAndSpinCount$descriptor() {
		return InitializeCriticalSectionAndSpinCount.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
	 *}
	 */
	public static MethodHandle InitializeCriticalSectionAndSpinCount$handle() {
		return InitializeCriticalSectionAndSpinCount.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
	 *}
	 */
	public static int InitializeCriticalSectionAndSpinCount(MemorySegment lpCriticalSection, int dwSpinCount) {
		var mh$ = InitializeCriticalSectionAndSpinCount.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("InitializeCriticalSectionAndSpinCount", lpCriticalSection, dwSpinCount);
			}
			return (int) mh$.invokeExact(lpCriticalSection, dwSpinCount);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class DeleteCriticalSection {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("DeleteCriticalSection"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * void DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
	 *}
	 */
	public static FunctionDescriptor DeleteCriticalSection$descriptor() {
		return DeleteCriticalSection.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * void DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
	 *}
	 */
	public static MethodHandle DeleteCriticalSection$handle() {
		return DeleteCriticalSection.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * void DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
	 *}
	 */
	public static void DeleteCriticalSection(MemorySegment lpCriticalSection) {
		var mh$ = DeleteCriticalSection.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("DeleteCriticalSection", lpCriticalSection);
			}
			mh$.invokeExact(lpCriticalSection);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class WakeAllConditionVariable {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("WakeAllConditionVariable"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * void WakeAllConditionVariable(PCONDITION_VARIABLE ConditionVariable)
	 *}
	 */
	public static FunctionDescriptor WakeAllConditionVariable$descriptor() {
		return WakeAllConditionVariable.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * void WakeAllConditionVariable(PCONDITION_VARIABLE ConditionVariable)
	 *}
	 */
	public static MethodHandle WakeAllConditionVariable$handle() {
		return WakeAllConditionVariable.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * void WakeAllConditionVariable(PCONDITION_VARIABLE ConditionVariable)
	 *}
	 */
	public static void WakeAllConditionVariable(MemorySegment ConditionVariable) {
		var mh$ = WakeAllConditionVariable.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("WakeAllConditionVariable", ConditionVariable);
			}
			mh$.invokeExact(ConditionVariable);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class SleepConditionVariableSRW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_INT,
				Windows.C_POINTER,
				Windows.C_POINTER,
				Windows.C_LONG,
				Windows.C_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("SleepConditionVariableSRW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL SleepConditionVariableSRW(PCONDITION_VARIABLE ConditionVariable, PSRWLOCK SRWLock, DWORD dwMilliseconds, ULONG Flags)
	 *}
	 */
	public static FunctionDescriptor SleepConditionVariableSRW$descriptor() {
		return SleepConditionVariableSRW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL SleepConditionVariableSRW(PCONDITION_VARIABLE ConditionVariable, PSRWLOCK SRWLock, DWORD dwMilliseconds, ULONG Flags)
	 *}
	 */
	public static MethodHandle SleepConditionVariableSRW$handle() {
		return SleepConditionVariableSRW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL SleepConditionVariableSRW(PCONDITION_VARIABLE ConditionVariable, PSRWLOCK SRWLock, DWORD dwMilliseconds, ULONG Flags)
	 *}
	 */
	public static int SleepConditionVariableSRW(MemorySegment ConditionVariable, MemorySegment SRWLock, int dwMilliseconds, int Flags) {
		var mh$ = SleepConditionVariableSRW.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("SleepConditionVariableSRW", ConditionVariable, SRWLock, dwMilliseconds, Flags);
			}
			return (int) mh$.invokeExact(ConditionVariable, SRWLock, dwMilliseconds, Flags);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class InitializeSListHead {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("InitializeSListHead"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * void InitializeSListHead(PSLIST_HEADER ListHead)
	 *}
	 */
	public static FunctionDescriptor InitializeSListHead$descriptor() {
		return InitializeSListHead.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * void InitializeSListHead(PSLIST_HEADER ListHead)
	 *}
	 */
	public static MethodHandle InitializeSListHead$handle() {
		return InitializeSListHead.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * void InitializeSListHead(PSLIST_HEADER ListHead)
	 *}
	 */
	public static void InitializeSListHead(MemorySegment ListHead) {
		var mh$ = InitializeSListHead.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("InitializeSListHead", ListHead);
			}
			mh$.invokeExact(ListHead);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class InterlockedFlushSList {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_POINTER,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("InterlockedFlushSList"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * PSLIST_ENTRY InterlockedFlushSList(PSLIST_HEADER ListHead)
	 *}
	 */
	public static FunctionDescriptor InterlockedFlushSList$descriptor() {
		return InterlockedFlushSList.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * PSLIST_ENTRY InterlockedFlushSList(PSLIST_HEADER ListHead)
	 *}
	 */
	public static MethodHandle InterlockedFlushSList$handle() {
		return InterlockedFlushSList.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * PSLIST_ENTRY InterlockedFlushSList(PSLIST_HEADER ListHead)
	 *}
	 */
	public static MemorySegment InterlockedFlushSList(MemorySegment ListHead) {
		var mh$ = InterlockedFlushSList.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("InterlockedFlushSList", ListHead);
			}
			return (MemorySegment) mh$.invokeExact(ListHead);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetCurrentProcess {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_POINTER);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("GetCurrentProcess"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * HANDLE GetCurrentProcess()
	 *}
	 */
	public static FunctionDescriptor GetCurrentProcess$descriptor() {
		return GetCurrentProcess.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * HANDLE GetCurrentProcess()
	 *}
	 */
	public static MethodHandle GetCurrentProcess$handle() {
		return GetCurrentProcess.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * HANDLE GetCurrentProcess()
	 *}
	 */
	public static MemorySegment GetCurrentProcess() {
		var mh$ = GetCurrentProcess.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("GetCurrentProcess");
			}
			return (MemorySegment) mh$.invokeExact();
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class ExitProcess {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				Windows.C_INT
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("ExitProcess"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * void ExitProcess(UINT uExitCode)
	 *}
	 */
	public static FunctionDescriptor ExitProcess$descriptor() {
		return ExitProcess.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * void ExitProcess(UINT uExitCode)
	 *}
	 */
	public static MethodHandle ExitProcess$handle() {
		return ExitProcess.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * void ExitProcess(UINT uExitCode)
	 *}
	 */
	public static void ExitProcess(int uExitCode) {
		var mh$ = ExitProcess.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("ExitProcess", uExitCode);
			}
			mh$.invokeExact(uExitCode);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetCurrentThreadId {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_LONG);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("GetCurrentThreadId"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * DWORD GetCurrentThreadId()
	 *}
	 */
	public static FunctionDescriptor GetCurrentThreadId$descriptor() {
		return GetCurrentThreadId.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * DWORD GetCurrentThreadId()
	 *}
	 */
	public static MethodHandle GetCurrentThreadId$handle() {
		return GetCurrentThreadId.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * DWORD GetCurrentThreadId()
	 *}
	 */
	public static int GetCurrentThreadId() {
		var mh$ = GetCurrentThreadId.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("GetCurrentThreadId");
			}
			return (int) mh$.invokeExact();
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class TlsAlloc {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_LONG);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("TlsAlloc"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * DWORD TlsAlloc()
	 *}
	 */
	public static FunctionDescriptor TlsAlloc$descriptor() {
		return TlsAlloc.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * DWORD TlsAlloc()
	 *}
	 */
	public static MethodHandle TlsAlloc$handle() {
		return TlsAlloc.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * DWORD TlsAlloc()
	 *}
	 */
	public static int TlsAlloc() {
		var mh$ = TlsAlloc.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("TlsAlloc");
			}
			return (int) mh$.invokeExact();
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class TlsGetValue {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_POINTER,
				Windows.C_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("TlsGetValue"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * LPVOID TlsGetValue(DWORD dwTlsIndex)
	 *}
	 */
	public static FunctionDescriptor TlsGetValue$descriptor() {
		return TlsGetValue.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * LPVOID TlsGetValue(DWORD dwTlsIndex)
	 *}
	 */
	public static MethodHandle TlsGetValue$handle() {
		return TlsGetValue.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * LPVOID TlsGetValue(DWORD dwTlsIndex)
	 *}
	 */
	public static MemorySegment TlsGetValue(int dwTlsIndex) {
		var mh$ = TlsGetValue.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("TlsGetValue", dwTlsIndex);
			}
			return (MemorySegment) mh$.invokeExact(dwTlsIndex);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class TlsSetValue {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_INT,
				Windows.C_LONG,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("TlsSetValue"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue)
	 *}
	 */
	public static FunctionDescriptor TlsSetValue$descriptor() {
		return TlsSetValue.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue)
	 *}
	 */
	public static MethodHandle TlsSetValue$handle() {
		return TlsSetValue.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue)
	 *}
	 */
	public static int TlsSetValue(int dwTlsIndex, MemorySegment lpTlsValue) {
		var mh$ = TlsSetValue.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("TlsSetValue", dwTlsIndex, lpTlsValue);
			}
			return (int) mh$.invokeExact(dwTlsIndex, lpTlsValue);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class TlsFree {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_INT,
				Windows.C_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("TlsFree"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL TlsFree(DWORD dwTlsIndex)
	 *}
	 */
	public static FunctionDescriptor TlsFree$descriptor() {
		return TlsFree.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL TlsFree(DWORD dwTlsIndex)
	 *}
	 */
	public static MethodHandle TlsFree$handle() {
		return TlsFree.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL TlsFree(DWORD dwTlsIndex)
	 *}
	 */
	public static int TlsFree(int dwTlsIndex) {
		var mh$ = TlsFree.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("TlsFree", dwTlsIndex);
			}
			return (int) mh$.invokeExact(dwTlsIndex);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetStartupInfoW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("GetStartupInfoW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * void GetStartupInfoW(LPSTARTUPINFOW lpStartupInfo)
	 *}
	 */
	public static FunctionDescriptor GetStartupInfoW$descriptor() {
		return GetStartupInfoW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * void GetStartupInfoW(LPSTARTUPINFOW lpStartupInfo)
	 *}
	 */
	public static MethodHandle GetStartupInfoW$handle() {
		return GetStartupInfoW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * void GetStartupInfoW(LPSTARTUPINFOW lpStartupInfo)
	 *}
	 */
	public static void GetStartupInfoW(MemorySegment lpStartupInfo) {
		var mh$ = GetStartupInfoW.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("GetStartupInfoW", lpStartupInfo);
			}
			mh$.invokeExact(lpStartupInfo);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class IsProcessorFeaturePresent {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_INT,
				Windows.C_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("IsProcessorFeaturePresent"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL IsProcessorFeaturePresent(DWORD ProcessorFeature)
	 *}
	 */
	public static FunctionDescriptor IsProcessorFeaturePresent$descriptor() {
		return IsProcessorFeaturePresent.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL IsProcessorFeaturePresent(DWORD ProcessorFeature)
	 *}
	 */
	public static MethodHandle IsProcessorFeaturePresent$handle() {
		return IsProcessorFeaturePresent.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL IsProcessorFeaturePresent(DWORD ProcessorFeature)
	 *}
	 */
	public static int IsProcessorFeaturePresent(int ProcessorFeature) {
		var mh$ = IsProcessorFeaturePresent.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("IsProcessorFeaturePresent", ProcessorFeature);
			}
			return (int) mh$.invokeExact(ProcessorFeature);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetSystemTimeAsFileTime {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("GetSystemTimeAsFileTime"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * void GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
	 *}
	 */
	public static FunctionDescriptor GetSystemTimeAsFileTime$descriptor() {
		return GetSystemTimeAsFileTime.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * void GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
	 *}
	 */
	public static MethodHandle GetSystemTimeAsFileTime$handle() {
		return GetSystemTimeAsFileTime.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * void GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
	 *}
	 */
	public static void GetSystemTimeAsFileTime(MemorySegment lpSystemTimeAsFileTime) {
		var mh$ = GetSystemTimeAsFileTime.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("GetSystemTimeAsFileTime", lpSystemTimeAsFileTime);
			}
			mh$.invokeExact(lpSystemTimeAsFileTime);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetModuleFileNameW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_LONG,
				Windows.C_POINTER,
				Windows.C_POINTER,
				Windows.C_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("GetModuleFileNameW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * DWORD GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize)
	 *}
	 */
	public static FunctionDescriptor GetModuleFileNameW$descriptor() {
		return GetModuleFileNameW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * DWORD GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize)
	 *}
	 */
	public static MethodHandle GetModuleFileNameW$handle() {
		return GetModuleFileNameW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * DWORD GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize)
	 *}
	 */
	public static int GetModuleFileNameW(MemorySegment hModule, MemorySegment lpFilename, int nSize) {
		var mh$ = GetModuleFileNameW.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("GetModuleFileNameW", hModule, lpFilename, nSize);
			}
			return (int) mh$.invokeExact(hModule, lpFilename, nSize);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetModuleHandleA {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_POINTER,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("GetModuleHandleA"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * HMODULE GetModuleHandleA(LPCSTR lpModuleName)
	 *}
	 */
	public static FunctionDescriptor GetModuleHandleA$descriptor() {
		return GetModuleHandleA.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * HMODULE GetModuleHandleA(LPCSTR lpModuleName)
	 *}
	 */
	public static MethodHandle GetModuleHandleA$handle() {
		return GetModuleHandleA.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * HMODULE GetModuleHandleA(LPCSTR lpModuleName)
	 *}
	 */
	public static MemorySegment GetModuleHandleA(MemorySegment lpModuleName) {
		var mh$ = GetModuleHandleA.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("GetModuleHandleA", lpModuleName);
			}
			return (MemorySegment) mh$.invokeExact(lpModuleName);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetModuleHandleExW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_BOOL,
				Windows.C_LONG,
				Windows.C_POINTER,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("GetModuleHandleExW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL GetModuleHandleExW(DWORD dwFlags, LPCWSTR lpModuleName, HMODULE *phModule)
	 *}
	 */
	public static FunctionDescriptor GetModuleHandleExW$descriptor() {
		return GetModuleHandleExW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL GetModuleHandleExW(DWORD dwFlags, LPCWSTR lpModuleName, HMODULE *phModule)
	 *}
	 */
	public static MethodHandle GetModuleHandleExW$handle() {
		return GetModuleHandleExW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL GetModuleHandleExW(DWORD dwFlags, LPCWSTR lpModuleName, HMODULE *phModule)
	 *}
	 */
	public static boolean GetModuleHandleExW(int dwFlags, MemorySegment lpModuleName, MemorySegment phModule) {
		var mh$ = GetModuleHandleExW.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("GetModuleHandleExW", dwFlags, lpModuleName, phModule);
			}
			return (boolean) mh$.invokeExact(dwFlags, lpModuleName, phModule);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class lstrcmpW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_INT,
				Windows.C_POINTER,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("lstrcmpW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * int lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2)
	 *}
	 */
	public static FunctionDescriptor lstrcmpW$descriptor() {
		return lstrcmpW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * int lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2)
	 *}
	 */
	public static MethodHandle lstrcmpW$handle() {
		return lstrcmpW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * int lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2)
	 *}
	 */
	public static int lstrcmpW(MemorySegment lpString1, MemorySegment lpString2) {
		var mh$ = lstrcmpW.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("lstrcmpW", lpString1, lpString2);
			}
			return (int) mh$.invokeExact(lpString1, lpString2);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	/**
	 * {@snippet lang = c:
	 * typedef struct tagMSG {
	 *     HWND hwnd;
	 *     UINT message;
	 *     WPARAM wParam;
	 *     LPARAM lParam;
	 *     DWORD time;
	 *     POINT pt;
	 * } *LPMSG
	 *}
	 */
	public static final AddressLayout LPMSG = Windows.C_POINTER;
	/**
	 * {@snippet lang = c:
	 * typedef struct tagMINMAXINFO {
	 *     POINT ptReserved;
	 *     POINT ptMaxSize;
	 *     POINT ptMaxPosition;
	 *     POINT ptMinTrackSize;
	 *     POINT ptMaxTrackSize;
	 * } *LPMINMAXINFO
	 *}
	 */
	public static final AddressLayout LPMINMAXINFO = Windows.C_POINTER;
	/**
	 * {@snippet lang = c:
	 * typedef LPCREATESTRUCTA LPCREATESTRUCT
	 *}
	 */
	public static final AddressLayout LPCREATESTRUCT = Windows.C_POINTER;
	
	private static class GetMessageW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_BOOL,
				Windows.C_POINTER,
				Windows.C_POINTER,
				Windows.C_INT,
				Windows.C_INT
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("GetMessageW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL GetMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
	 *}
	 */
	public static FunctionDescriptor GetMessageW$descriptor() {
		return GetMessageW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL GetMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
	 *}
	 */
	public static MethodHandle GetMessageW$handle() {
		return GetMessageW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL GetMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
	 *}
	 */
	public static boolean GetMessageW(MemorySegment lpMsg, MemorySegment hWnd, int wMsgFilterMin, int wMsgFilterMax) {
		var mh$ = GetMessageW.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("GetMessageW", lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
			}
			return (boolean) mh$.invokeExact(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class TranslateMessage {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_BOOL,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("TranslateMessage"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL TranslateMessage(const MSG *lpMsg)
	 *}
	 */
	public static FunctionDescriptor TranslateMessage$descriptor() {
		return TranslateMessage.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL TranslateMessage(const MSG *lpMsg)
	 *}
	 */
	public static MethodHandle TranslateMessage$handle() {
		return TranslateMessage.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL TranslateMessage(const MSG *lpMsg)
	 *}
	 */
	public static boolean TranslateMessage(MemorySegment lpMsg) {
		var mh$ = TranslateMessage.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("TranslateMessage", lpMsg);
			}
			return (boolean) mh$.invokeExact(lpMsg);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class DispatchMessageW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_LONG_LONG,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("DispatchMessageW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * LRESULT DispatchMessageW(const MSG *lpMsg)
	 *}
	 */
	public static FunctionDescriptor DispatchMessageW$descriptor() {
		return DispatchMessageW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * LRESULT DispatchMessageW(const MSG *lpMsg)
	 *}
	 */
	public static MethodHandle DispatchMessageW$handle() {
		return DispatchMessageW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * LRESULT DispatchMessageW(const MSG *lpMsg)
	 *}
	 */
	public static long DispatchMessageW(MemorySegment lpMsg) {
		var mh$ = DispatchMessageW.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("DispatchMessageW", lpMsg);
			}
			return (long) mh$.invokeExact(lpMsg);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class PostMessageW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_BOOL,
				Windows.C_POINTER,
				Windows.C_INT,
				Windows.C_LONG_LONG,
				Windows.C_LONG_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("PostMessageW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
	 *}
	 */
	public static FunctionDescriptor PostMessageW$descriptor() {
		return PostMessageW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
	 *}
	 */
	public static MethodHandle PostMessageW$handle() {
		return PostMessageW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
	 *}
	 */
	public static boolean PostMessageW(MemorySegment hWnd, int Msg, long wParam, long lParam) {
		var mh$ = PostMessageW.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("PostMessageW", hWnd, Msg, wParam, lParam);
			}
			return (boolean) mh$.invokeExact(hWnd, Msg, wParam, lParam);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class DefWindowProcW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_LONG_LONG,
				Windows.C_POINTER,
				Windows.C_INT,
				Windows.C_LONG_LONG,
				Windows.C_LONG_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("DefWindowProcW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * LRESULT DefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
	 *}
	 */
	public static FunctionDescriptor DefWindowProcW$descriptor() {
		return DefWindowProcW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * LRESULT DefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
	 *}
	 */
	public static MethodHandle DefWindowProcW$handle() {
		return DefWindowProcW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * LRESULT DefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
	 *}
	 */
	public static long DefWindowProcW(MemorySegment hWnd, int Msg, long wParam, long lParam) {
		var mh$ = DefWindowProcW.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("DefWindowProcW", hWnd, Msg, wParam, lParam);
			}
			return (long) mh$.invokeExact(hWnd, Msg, wParam, lParam);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class PostQuitMessage {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				Windows.C_INT
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("PostQuitMessage"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * void PostQuitMessage(int nExitCode)
	 *}
	 */
	public static FunctionDescriptor PostQuitMessage$descriptor() {
		return PostQuitMessage.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * void PostQuitMessage(int nExitCode)
	 *}
	 */
	public static MethodHandle PostQuitMessage$handle() {
		return PostQuitMessage.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * void PostQuitMessage(int nExitCode)
	 *}
	 */
	public static void PostQuitMessage(int nExitCode) {
		var mh$ = PostQuitMessage.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("PostQuitMessage", nExitCode);
			}
			mh$.invokeExact(nExitCode);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class RegisterClassExW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_SHORT,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("RegisterClassExW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * ATOM RegisterClassExW(const WNDCLASSEXW *)
	 *}
	 */
	public static FunctionDescriptor RegisterClassExW$descriptor() {
		return RegisterClassExW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * ATOM RegisterClassExW(const WNDCLASSEXW *)
	 *}
	 */
	public static MethodHandle RegisterClassExW$handle() {
		return RegisterClassExW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * ATOM RegisterClassExW(const WNDCLASSEXW *)
	 *}
	 */
	public static short RegisterClassExW(MemorySegment x0) {
		var mh$ = RegisterClassExW.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("RegisterClassExW", x0);
			}
			return (short) mh$.invokeExact(x0);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class CreateWindowExW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_POINTER,
				Windows.C_LONG,
				Windows.C_POINTER,
				Windows.C_POINTER,
				Windows.C_LONG,
				Windows.C_INT,
				Windows.C_INT,
				Windows.C_INT,
				Windows.C_INT,
				Windows.C_POINTER,
				Windows.C_POINTER,
				Windows.C_POINTER,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("CreateWindowExW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * HWND CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
	 *}
	 */
	public static FunctionDescriptor CreateWindowExW$descriptor() {
		return CreateWindowExW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * HWND CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
	 *}
	 */
	public static MethodHandle CreateWindowExW$handle() {
		return CreateWindowExW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * HWND CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
	 *}
	 */
	public static MemorySegment CreateWindowExW(int dwExStyle, MemorySegment lpClassName, MemorySegment lpWindowName, int dwStyle, int X, int Y, int nWidth, int nHeight, MemorySegment hWndParent, MemorySegment hMenu, MemorySegment hInstance, MemorySegment lpParam) {
		var mh$ = CreateWindowExW.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("CreateWindowExW", dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
			}
			return (MemorySegment) mh$.invokeExact(dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class IsWindow {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_INT,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("IsWindow"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL IsWindow(HWND hWnd)
	 *}
	 */
	public static FunctionDescriptor IsWindow$descriptor() {
		return IsWindow.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL IsWindow(HWND hWnd)
	 *}
	 */
	public static MethodHandle IsWindow$handle() {
		return IsWindow.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL IsWindow(HWND hWnd)
	 *}
	 */
	public static int IsWindow(MemorySegment hWnd) {
		var mh$ = IsWindow.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("IsWindow", hWnd);
			}
			return (int) mh$.invokeExact(hWnd);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class DestroyWindow {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_BOOL,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("DestroyWindow"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL DestroyWindow(HWND hWnd)
	 *}
	 */
	public static FunctionDescriptor DestroyWindow$descriptor() {
		return DestroyWindow.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL DestroyWindow(HWND hWnd)
	 *}
	 */
	public static MethodHandle DestroyWindow$handle() {
		return DestroyWindow.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL DestroyWindow(HWND hWnd)
	 *}
	 */
	public static boolean DestroyWindow(MemorySegment hWnd) {
		var mh$ = DestroyWindow.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("DestroyWindow", hWnd);
			}
			return (boolean) mh$.invokeExact(hWnd);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class ShowWindow {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_BOOL,
				Windows.C_POINTER,
				Windows.C_INT
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("ShowWindow"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL ShowWindow(HWND hWnd, int nCmdShow)
	 *}
	 */
	public static FunctionDescriptor ShowWindow$descriptor() {
		return ShowWindow.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL ShowWindow(HWND hWnd, int nCmdShow)
	 *}
	 */
	public static MethodHandle ShowWindow$handle() {
		return ShowWindow.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL ShowWindow(HWND hWnd, int nCmdShow)
	 *}
	 */
	public static boolean ShowWindow(MemorySegment hWnd, int nCmdShow) {
		var mh$ = ShowWindow.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("ShowWindow", hWnd, nCmdShow);
			}
			return (boolean) mh$.invokeExact(hWnd, nCmdShow);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class MoveWindow {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_INT,
				Windows.C_POINTER,
				Windows.C_INT,
				Windows.C_INT,
				Windows.C_INT,
				Windows.C_INT,
				Windows.C_INT
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("MoveWindow"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
	 *}
	 */
	public static FunctionDescriptor MoveWindow$descriptor() {
		return MoveWindow.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
	 *}
	 */
	public static MethodHandle MoveWindow$handle() {
		return MoveWindow.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
	 *}
	 */
	public static int MoveWindow(MemorySegment hWnd, int X, int Y, int nWidth, int nHeight, int bRepaint) {
		var mh$ = MoveWindow.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("MoveWindow", hWnd, X, Y, nWidth, nHeight, bRepaint);
			}
			return (int) mh$.invokeExact(hWnd, X, Y, nWidth, nHeight, bRepaint);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class SetWindowPos {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_INT,
				Windows.C_POINTER,
				Windows.C_POINTER,
				Windows.C_INT,
				Windows.C_INT,
				Windows.C_INT,
				Windows.C_INT,
				Windows.C_INT
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("SetWindowPos"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags)
	 *}
	 */
	public static FunctionDescriptor SetWindowPos$descriptor() {
		return SetWindowPos.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags)
	 *}
	 */
	public static MethodHandle SetWindowPos$handle() {
		return SetWindowPos.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags)
	 *}
	 */
	public static int SetWindowPos(MemorySegment hWnd, MemorySegment hWndInsertAfter, int X, int Y, int cx, int cy, int uFlags) {
		var mh$ = SetWindowPos.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("SetWindowPos", hWnd, hWndInsertAfter, X, Y, cx, cy, uFlags);
			}
			return (int) mh$.invokeExact(hWnd, hWndInsertAfter, X, Y, cx, cy, uFlags);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class SetFocus {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_POINTER,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("SetFocus"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * HWND SetFocus(HWND hWnd)
	 *}
	 */
	public static FunctionDescriptor SetFocus$descriptor() {
		return SetFocus.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * HWND SetFocus(HWND hWnd)
	 *}
	 */
	public static MethodHandle SetFocus$handle() {
		return SetFocus.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * HWND SetFocus(HWND hWnd)
	 *}
	 */
	public static MemorySegment SetFocus(MemorySegment hWnd) {
		var mh$ = SetFocus.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("SetFocus", hWnd);
			}
			return (MemorySegment) mh$.invokeExact(hWnd);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetSystemMetrics {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_INT,
				Windows.C_INT
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("GetSystemMetrics"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * int GetSystemMetrics(int nIndex)
	 *}
	 */
	public static FunctionDescriptor GetSystemMetrics$descriptor() {
		return GetSystemMetrics.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * int GetSystemMetrics(int nIndex)
	 *}
	 */
	public static MethodHandle GetSystemMetrics$handle() {
		return GetSystemMetrics.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * int GetSystemMetrics(int nIndex)
	 *}
	 */
	public static int GetSystemMetrics(int nIndex) {
		var mh$ = GetSystemMetrics.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("GetSystemMetrics", nIndex);
			}
			return (int) mh$.invokeExact(nIndex);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class UpdateWindow {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_BOOL,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("UpdateWindow"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL UpdateWindow(HWND hWnd)
	 *}
	 */
	public static FunctionDescriptor UpdateWindow$descriptor() {
		return UpdateWindow.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL UpdateWindow(HWND hWnd)
	 *}
	 */
	public static MethodHandle UpdateWindow$handle() {
		return UpdateWindow.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL UpdateWindow(HWND hWnd)
	 *}
	 */
	public static boolean UpdateWindow(MemorySegment hWnd) {
		var mh$ = UpdateWindow.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("UpdateWindow", hWnd);
			}
			return (boolean) mh$.invokeExact(hWnd);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class SetWindowTextW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_INT,
				Windows.C_POINTER,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("SetWindowTextW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL SetWindowTextW(HWND hWnd, LPCWSTR lpString)
	 *}
	 */
	public static FunctionDescriptor SetWindowTextW$descriptor() {
		return SetWindowTextW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL SetWindowTextW(HWND hWnd, LPCWSTR lpString)
	 *}
	 */
	public static MethodHandle SetWindowTextW$handle() {
		return SetWindowTextW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL SetWindowTextW(HWND hWnd, LPCWSTR lpString)
	 *}
	 */
	public static int SetWindowTextW(MemorySegment hWnd, MemorySegment lpString) {
		var mh$ = SetWindowTextW.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("SetWindowTextW", hWnd, lpString);
			}
			return (int) mh$.invokeExact(hWnd, lpString);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetClientRect {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_BOOL,
				Windows.C_POINTER,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("GetClientRect"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL GetClientRect(HWND hWnd, LPRECT lpRect)
	 *}
	 */
	public static FunctionDescriptor GetClientRect$descriptor() {
		return GetClientRect.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL GetClientRect(HWND hWnd, LPRECT lpRect)
	 *}
	 */
	public static MethodHandle GetClientRect$handle() {
		return GetClientRect.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL GetClientRect(HWND hWnd, LPRECT lpRect)
	 *}
	 */
	public static boolean GetClientRect(MemorySegment hWnd, MemorySegment lpRect) {
		var mh$ = GetClientRect.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("GetClientRect", hWnd, lpRect);
			}
			return (boolean) mh$.invokeExact(hWnd, lpRect);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class AdjustWindowRect {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_BOOL,
				Windows.C_POINTER,
				Windows.C_LONG,
				Windows.C_INT
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("AdjustWindowRect"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL AdjustWindowRect(LPRECT lpRect, DWORD dwStyle, BOOL bMenu)
	 *}
	 */
	public static FunctionDescriptor AdjustWindowRect$descriptor() {
		return AdjustWindowRect.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL AdjustWindowRect(LPRECT lpRect, DWORD dwStyle, BOOL bMenu)
	 *}
	 */
	public static MethodHandle AdjustWindowRect$handle() {
		return AdjustWindowRect.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL AdjustWindowRect(LPRECT lpRect, DWORD dwStyle, BOOL bMenu)
	 *}
	 */
	public static boolean AdjustWindowRect(MemorySegment lpRect, int dwStyle, int bMenu) {
		var mh$ = AdjustWindowRect.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("AdjustWindowRect", lpRect, dwStyle, bMenu);
			}
			return (boolean) mh$.invokeExact(lpRect, dwStyle, bMenu);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetWindowLongA {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_LONG,
				Windows.C_POINTER,
				Windows.C_INT
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("GetWindowLongA"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * LONG GetWindowLongA(HWND hWnd, int nIndex)
	 *}
	 */
	public static FunctionDescriptor GetWindowLongA$descriptor() {
		return GetWindowLongA.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * LONG GetWindowLongA(HWND hWnd, int nIndex)
	 *}
	 */
	public static MethodHandle GetWindowLongA$handle() {
		return GetWindowLongA.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * LONG GetWindowLongA(HWND hWnd, int nIndex)
	 *}
	 */
	public static int GetWindowLongA(MemorySegment hWnd, int nIndex) {
		var mh$ = GetWindowLongA.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("GetWindowLongA", hWnd, nIndex);
			}
			return (int) mh$.invokeExact(hWnd, nIndex);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class SetWindowLongA {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_LONG,
				Windows.C_POINTER,
				Windows.C_INT,
				Windows.C_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("SetWindowLongA"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * LONG SetWindowLongA(HWND hWnd, int nIndex, LONG dwNewLong)
	 *}
	 */
	public static FunctionDescriptor SetWindowLongA$descriptor() {
		return SetWindowLongA.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * LONG SetWindowLongA(HWND hWnd, int nIndex, LONG dwNewLong)
	 *}
	 */
	public static MethodHandle SetWindowLongA$handle() {
		return SetWindowLongA.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * LONG SetWindowLongA(HWND hWnd, int nIndex, LONG dwNewLong)
	 *}
	 */
	public static int SetWindowLongA(MemorySegment hWnd, int nIndex, int dwNewLong) {
		var mh$ = SetWindowLongA.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("SetWindowLongA", hWnd, nIndex, dwNewLong);
			}
			return (int) mh$.invokeExact(hWnd, nIndex, dwNewLong);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetWindowLongPtrW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_LONG_LONG,
				Windows.C_POINTER,
				Windows.C_INT
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("GetWindowLongPtrW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * LONG_PTR GetWindowLongPtrW(HWND hWnd, int nIndex)
	 *}
	 */
	public static FunctionDescriptor GetWindowLongPtrW$descriptor() {
		return GetWindowLongPtrW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * LONG_PTR GetWindowLongPtrW(HWND hWnd, int nIndex)
	 *}
	 */
	public static MethodHandle GetWindowLongPtrW$handle() {
		return GetWindowLongPtrW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * LONG_PTR GetWindowLongPtrW(HWND hWnd, int nIndex)
	 *}
	 */
	public static long GetWindowLongPtrW(MemorySegment hWnd, int nIndex) {
		var mh$ = GetWindowLongPtrW.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("GetWindowLongPtrW", hWnd, nIndex);
			}
			return (long) mh$.invokeExact(hWnd, nIndex);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class SetWindowLongPtrW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_LONG_LONG,
				Windows.C_POINTER,
				Windows.C_INT,
				Windows.C_LONG_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("SetWindowLongPtrW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * LONG_PTR SetWindowLongPtrW(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
	 *}
	 */
	public static FunctionDescriptor SetWindowLongPtrW$descriptor() {
		return SetWindowLongPtrW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * LONG_PTR SetWindowLongPtrW(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
	 *}
	 */
	public static MethodHandle SetWindowLongPtrW$handle() {
		return SetWindowLongPtrW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * LONG_PTR SetWindowLongPtrW(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
	 *}
	 */
	public static long SetWindowLongPtrW(MemorySegment hWnd, int nIndex, long dwNewLong) {
		var mh$ = SetWindowLongPtrW.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("SetWindowLongPtrW", hWnd, nIndex, dwNewLong);
			}
			return (long) mh$.invokeExact(hWnd, nIndex, dwNewLong);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetParent {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_POINTER,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("GetParent"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * HWND GetParent(HWND hWnd)
	 *}
	 */
	public static FunctionDescriptor GetParent$descriptor() {
		return GetParent.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * HWND GetParent(HWND hWnd)
	 *}
	 */
	public static MethodHandle GetParent$handle() {
		return GetParent.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * HWND GetParent(HWND hWnd)
	 *}
	 */
	public static MemorySegment GetParent(MemorySegment hWnd) {
		var mh$ = GetParent.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("GetParent", hWnd);
			}
			return (MemorySegment) mh$.invokeExact(hWnd);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class LoadImageA {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_POINTER,
				Windows.C_POINTER,
				Windows.C_POINTER,
				Windows.C_INT,
				Windows.C_INT,
				Windows.C_INT,
				Windows.C_INT
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("LoadImageA"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * HANDLE LoadImageA(HINSTANCE hInst, LPCSTR name, UINT type, int cx, int cy, UINT fuLoad)
	 *}
	 */
	public static FunctionDescriptor LoadImageA$descriptor() {
		return LoadImageA.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * HANDLE LoadImageA(HINSTANCE hInst, LPCSTR name, UINT type, int cx, int cy, UINT fuLoad)
	 *}
	 */
	public static MethodHandle LoadImageA$handle() {
		return LoadImageA.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * HANDLE LoadImageA(HINSTANCE hInst, LPCSTR name, UINT type, int cx, int cy, UINT fuLoad)
	 *}
	 */
	public static MemorySegment LoadImageA(MemorySegment hInst, MemorySegment name, int type, int cx, int cy, int fuLoad) {
		var mh$ = LoadImageA.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("LoadImageA", hInst, name, type, cx, cy, fuLoad);
			}
			return (MemorySegment) mh$.invokeExact(hInst, name, type, cx, cy, fuLoad);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class SetProcessDpiAwarenessContext {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_BOOL,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("SetProcessDpiAwarenessContext"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
	 *}
	 */
	public static FunctionDescriptor SetProcessDpiAwarenessContext$descriptor() {
		return SetProcessDpiAwarenessContext.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
	 *}
	 */
	public static MethodHandle SetProcessDpiAwarenessContext$handle() {
		return SetProcessDpiAwarenessContext.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
	 *}
	 */
	public static boolean SetProcessDpiAwarenessContext(MemorySegment value) {
		var mh$ = SetProcessDpiAwarenessContext.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("SetProcessDpiAwarenessContext", value);
			}
			return (boolean) mh$.invokeExact(value);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class MultiByteToWideChar {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_INT,
				Windows.C_INT,
				Windows.C_LONG,
				Windows.C_POINTER,
				Windows.C_INT,
				Windows.C_POINTER,
				Windows.C_INT
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("MultiByteToWideChar"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * int MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar)
	 *}
	 */
	public static FunctionDescriptor MultiByteToWideChar$descriptor() {
		return MultiByteToWideChar.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * int MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar)
	 *}
	 */
	public static MethodHandle MultiByteToWideChar$handle() {
		return MultiByteToWideChar.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * int MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar)
	 *}
	 */
	public static int MultiByteToWideChar(int CodePage, int dwFlags, MemorySegment lpMultiByteStr, int cbMultiByte, MemorySegment lpWideCharStr, int cchWideChar) {
		var mh$ = MultiByteToWideChar.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("MultiByteToWideChar", CodePage, dwFlags, lpMultiByteStr, cbMultiByte, lpWideCharStr, cchWideChar);
			}
			return (int) mh$.invokeExact(CodePage, dwFlags, lpMultiByteStr, cbMultiByte, lpWideCharStr, cchWideChar);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class WideCharToMultiByte {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_INT,
				Windows.C_INT,
				Windows.C_LONG,
				Windows.C_POINTER,
				Windows.C_INT,
				Windows.C_POINTER,
				Windows.C_INT,
				Windows.C_POINTER,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("WideCharToMultiByte"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * int WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar)
	 *}
	 */
	public static FunctionDescriptor WideCharToMultiByte$descriptor() {
		return WideCharToMultiByte.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * int WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar)
	 *}
	 */
	public static MethodHandle WideCharToMultiByte$handle() {
		return WideCharToMultiByte.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * int WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar)
	 *}
	 */
	public static int WideCharToMultiByte(int CodePage, int dwFlags, MemorySegment lpWideCharStr, int cchWideChar, MemorySegment lpMultiByteStr, int cbMultiByte, MemorySegment lpDefaultChar, MemorySegment lpUsedDefaultChar) {
		var mh$ = WideCharToMultiByte.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("WideCharToMultiByte", CodePage, dwFlags, lpWideCharStr, cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar);
			}
			return (int) mh$.invokeExact(CodePage, dwFlags, lpWideCharStr, cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class IsValidCodePage {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_INT,
				Windows.C_INT
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("IsValidCodePage"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL IsValidCodePage(UINT CodePage)
	 *}
	 */
	public static FunctionDescriptor IsValidCodePage$descriptor() {
		return IsValidCodePage.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL IsValidCodePage(UINT CodePage)
	 *}
	 */
	public static MethodHandle IsValidCodePage$handle() {
		return IsValidCodePage.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL IsValidCodePage(UINT CodePage)
	 *}
	 */
	public static int IsValidCodePage(int CodePage) {
		var mh$ = IsValidCodePage.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("IsValidCodePage", CodePage);
			}
			return (int) mh$.invokeExact(CodePage);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetACP {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_INT);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("GetACP"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * UINT GetACP()
	 *}
	 */
	public static FunctionDescriptor GetACP$descriptor() {
		return GetACP.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * UINT GetACP()
	 *}
	 */
	public static MethodHandle GetACP$handle() {
		return GetACP.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * UINT GetACP()
	 *}
	 */
	public static int GetACP() {
		var mh$ = GetACP.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("GetACP");
			}
			return (int) mh$.invokeExact();
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetOEMCP {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_INT);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("GetOEMCP"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * UINT GetOEMCP()
	 *}
	 */
	public static FunctionDescriptor GetOEMCP$descriptor() {
		return GetOEMCP.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * UINT GetOEMCP()
	 *}
	 */
	public static MethodHandle GetOEMCP$handle() {
		return GetOEMCP.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * UINT GetOEMCP()
	 *}
	 */
	public static int GetOEMCP() {
		var mh$ = GetOEMCP.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("GetOEMCP");
			}
			return (int) mh$.invokeExact();
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetCPInfo {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_BOOL,
				Windows.C_INT,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("GetCPInfo"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo)
	 *}
	 */
	public static FunctionDescriptor GetCPInfo$descriptor() {
		return GetCPInfo.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo)
	 *}
	 */
	public static MethodHandle GetCPInfo$handle() {
		return GetCPInfo.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo)
	 *}
	 */
	public static boolean GetCPInfo(int CodePage, MemorySegment lpCPInfo) {
		var mh$ = GetCPInfo.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("GetCPInfo", CodePage, lpCPInfo);
			}
			return (boolean) mh$.invokeExact(CodePage, lpCPInfo);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class LCMapStringW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_INT,
				Windows.C_LONG,
				Windows.C_LONG,
				Windows.C_POINTER,
				Windows.C_INT,
				Windows.C_POINTER,
				Windows.C_INT
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("LCMapStringW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * int LCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
	 *}
	 */
	public static FunctionDescriptor LCMapStringW$descriptor() {
		return LCMapStringW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * int LCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
	 *}
	 */
	public static MethodHandle LCMapStringW$handle() {
		return LCMapStringW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * int LCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
	 *}
	 */
	public static int LCMapStringW(int Locale, int dwMapFlags, MemorySegment lpSrcStr, int cchSrc, MemorySegment lpDestStr, int cchDest) {
		var mh$ = LCMapStringW.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("LCMapStringW", Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
			}
			return (int) mh$.invokeExact(Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetConsoleOutputCP {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_INT);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("GetConsoleOutputCP"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * UINT GetConsoleOutputCP()
	 *}
	 */
	public static FunctionDescriptor GetConsoleOutputCP$descriptor() {
		return GetConsoleOutputCP.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * UINT GetConsoleOutputCP()
	 *}
	 */
	public static MethodHandle GetConsoleOutputCP$handle() {
		return GetConsoleOutputCP.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * UINT GetConsoleOutputCP()
	 *}
	 */
	public static int GetConsoleOutputCP() {
		var mh$ = GetConsoleOutputCP.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("GetConsoleOutputCP");
			}
			return (int) mh$.invokeExact();
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetConsoleMode {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_BOOL,
				Windows.C_POINTER,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("GetConsoleMode"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode)
	 *}
	 */
	public static FunctionDescriptor GetConsoleMode$descriptor() {
		return GetConsoleMode.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode)
	 *}
	 */
	public static MethodHandle GetConsoleMode$handle() {
		return GetConsoleMode.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode)
	 *}
	 */
	public static boolean GetConsoleMode(MemorySegment hConsoleHandle, MemorySegment lpMode) {
		var mh$ = GetConsoleMode.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("GetConsoleMode", hConsoleHandle, lpMode);
			}
			return (boolean) mh$.invokeExact(hConsoleHandle, lpMode);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class WriteConsoleW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_INT,
				Windows.C_POINTER,
				Windows.C_POINTER,
				Windows.C_LONG,
				Windows.C_POINTER,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("WriteConsoleW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL WriteConsoleW(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
	 *}
	 */
	public static FunctionDescriptor WriteConsoleW$descriptor() {
		return WriteConsoleW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL WriteConsoleW(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
	 *}
	 */
	public static MethodHandle WriteConsoleW$handle() {
		return WriteConsoleW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL WriteConsoleW(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
	 *}
	 */
	public static int WriteConsoleW(MemorySegment hConsoleOutput, MemorySegment lpBuffer, int nNumberOfCharsToWrite, MemorySegment lpNumberOfCharsWritten, MemorySegment lpReserved) {
		var mh$ = WriteConsoleW.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("WriteConsoleW", hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved);
			}
			return (int) mh$.invokeExact(hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetFileVersionInfoSizeW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_LONG,
				Windows.C_POINTER,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("GetFileVersionInfoSizeW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * DWORD GetFileVersionInfoSizeW(LPCWSTR lptstrFilename, LPDWORD lpdwHandle)
	 *}
	 */
	public static FunctionDescriptor GetFileVersionInfoSizeW$descriptor() {
		return GetFileVersionInfoSizeW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * DWORD GetFileVersionInfoSizeW(LPCWSTR lptstrFilename, LPDWORD lpdwHandle)
	 *}
	 */
	public static MethodHandle GetFileVersionInfoSizeW$handle() {
		return GetFileVersionInfoSizeW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * DWORD GetFileVersionInfoSizeW(LPCWSTR lptstrFilename, LPDWORD lpdwHandle)
	 *}
	 */
	public static int GetFileVersionInfoSizeW(MemorySegment lptstrFilename, MemorySegment lpdwHandle) {
		var mh$ = GetFileVersionInfoSizeW.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("GetFileVersionInfoSizeW", lptstrFilename, lpdwHandle);
			}
			return (int) mh$.invokeExact(lptstrFilename, lpdwHandle);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class GetFileVersionInfoW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_INT,
				Windows.C_POINTER,
				Windows.C_LONG,
				Windows.C_LONG,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("GetFileVersionInfoW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL GetFileVersionInfoW(LPCWSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
	 *}
	 */
	public static FunctionDescriptor GetFileVersionInfoW$descriptor() {
		return GetFileVersionInfoW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL GetFileVersionInfoW(LPCWSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
	 *}
	 */
	public static MethodHandle GetFileVersionInfoW$handle() {
		return GetFileVersionInfoW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL GetFileVersionInfoW(LPCWSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
	 *}
	 */
	public static int GetFileVersionInfoW(MemorySegment lptstrFilename, int dwHandle, int dwLen, MemorySegment lpData) {
		var mh$ = GetFileVersionInfoW.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("GetFileVersionInfoW", lptstrFilename, dwHandle, dwLen, lpData);
			}
			return (int) mh$.invokeExact(lptstrFilename, dwHandle, dwLen, lpData);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class VerQueryValueW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_INT,
				Windows.C_POINTER,
				Windows.C_POINTER,
				Windows.C_POINTER,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("VerQueryValueW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * BOOL VerQueryValueW(LPCVOID pBlock, LPCWSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
	 *}
	 */
	public static FunctionDescriptor VerQueryValueW$descriptor() {
		return VerQueryValueW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * BOOL VerQueryValueW(LPCVOID pBlock, LPCWSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
	 *}
	 */
	public static MethodHandle VerQueryValueW$handle() {
		return VerQueryValueW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * BOOL VerQueryValueW(LPCVOID pBlock, LPCWSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
	 *}
	 */
	public static int VerQueryValueW(MemorySegment pBlock, MemorySegment lpSubBlock, MemorySegment lplpBuffer, MemorySegment puLen) {
		var mh$ = VerQueryValueW.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("VerQueryValueW", pBlock, lpSubBlock, lplpBuffer, puLen);
			}
			return (int) mh$.invokeExact(pBlock, lpSubBlock, lplpBuffer, puLen);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class RegCloseKey {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_LONG,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("RegCloseKey"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * LSTATUS RegCloseKey(HKEY hKey)
	 *}
	 */
	public static FunctionDescriptor RegCloseKey$descriptor() {
		return RegCloseKey.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * LSTATUS RegCloseKey(HKEY hKey)
	 *}
	 */
	public static MethodHandle RegCloseKey$handle() {
		return RegCloseKey.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * LSTATUS RegCloseKey(HKEY hKey)
	 *}
	 */
	public static int RegCloseKey(MemorySegment hKey) {
		var mh$ = RegCloseKey.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("RegCloseKey", hKey);
			}
			return (int) mh$.invokeExact(hKey);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class RegOpenKeyExW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_LONG,
				Windows.C_POINTER,
				Windows.C_POINTER,
				Windows.C_LONG,
				Windows.C_LONG,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("RegOpenKeyExW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * LSTATUS RegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
	 *}
	 */
	public static FunctionDescriptor RegOpenKeyExW$descriptor() {
		return RegOpenKeyExW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * LSTATUS RegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
	 *}
	 */
	public static MethodHandle RegOpenKeyExW$handle() {
		return RegOpenKeyExW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * LSTATUS RegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
	 *}
	 */
	public static int RegOpenKeyExW(MemorySegment hKey, MemorySegment lpSubKey, int ulOptions, int samDesired, MemorySegment phkResult) {
		var mh$ = RegOpenKeyExW.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("RegOpenKeyExW", hKey, lpSubKey, ulOptions, samDesired, phkResult);
			}
			return (int) mh$.invokeExact(hKey, lpSubKey, ulOptions, samDesired, phkResult);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class RegQueryValueExW {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_LONG,
				Windows.C_POINTER,
				Windows.C_POINTER,
				Windows.C_POINTER,
				Windows.C_POINTER,
				Windows.C_POINTER,
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("RegQueryValueExW"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * LSTATUS RegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
	 *}
	 */
	public static FunctionDescriptor RegQueryValueExW$descriptor() {
		return RegQueryValueExW.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * LSTATUS RegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
	 *}
	 */
	public static MethodHandle RegQueryValueExW$handle() {
		return RegQueryValueExW.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * LSTATUS RegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
	 *}
	 */
	public static int RegQueryValueExW(MemorySegment hKey, MemorySegment lpValueName, MemorySegment lpReserved, MemorySegment lpType, MemorySegment lpData, MemorySegment lpcbData) {
		var mh$ = RegQueryValueExW.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("RegQueryValueExW", hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);
			}
			return (int) mh$.invokeExact(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class CoUninitialize {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid();
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("CoUninitialize"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * extern void CoUninitialize()
	 *}
	 */
	public static FunctionDescriptor CoUninitialize$descriptor() {
		return CoUninitialize.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * extern void CoUninitialize()
	 *}
	 */
	public static MethodHandle CoUninitialize$handle() {
		return CoUninitialize.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * extern void CoUninitialize()
	 *}
	 */
	public static void CoUninitialize() {
		var mh$ = CoUninitialize.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("CoUninitialize");
			}
			mh$.invokeExact();
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class CoInitializeEx {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_LONG,
				Windows.C_POINTER,
				Windows.C_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("CoInitializeEx"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * extern HRESULT CoInitializeEx(LPVOID pvReserved, DWORD dwCoInit)
	 *}
	 */
	public static FunctionDescriptor CoInitializeEx$descriptor() {
		return CoInitializeEx.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * extern HRESULT CoInitializeEx(LPVOID pvReserved, DWORD dwCoInit)
	 *}
	 */
	public static MethodHandle CoInitializeEx$handle() {
		return CoInitializeEx.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * extern HRESULT CoInitializeEx(LPVOID pvReserved, DWORD dwCoInit)
	 *}
	 */
	public static int CoInitializeEx(MemorySegment pvReserved, int dwCoInit) {
		var mh$ = CoInitializeEx.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("CoInitializeEx", pvReserved, dwCoInit);
			}
			return (int) mh$.invokeExact(pvReserved, dwCoInit);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class CoTaskMemAlloc {
		public static final FunctionDescriptor DESC = FunctionDescriptor.of(
				Windows.C_POINTER,
				Windows.C_LONG_LONG
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("CoTaskMemAlloc"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * extern LPVOID CoTaskMemAlloc(SIZE_T cb)
	 *}
	 */
	public static FunctionDescriptor CoTaskMemAlloc$descriptor() {
		return CoTaskMemAlloc.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * extern LPVOID CoTaskMemAlloc(SIZE_T cb)
	 *}
	 */
	public static MethodHandle CoTaskMemAlloc$handle() {
		return CoTaskMemAlloc.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * extern LPVOID CoTaskMemAlloc(SIZE_T cb)
	 *}
	 */
	public static MemorySegment CoTaskMemAlloc(long cb) {
		var mh$ = CoTaskMemAlloc.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("CoTaskMemAlloc", cb);
			}
			return (MemorySegment) mh$.invokeExact(cb);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
	
	private static class CoTaskMemFree {
		public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
				Windows.C_POINTER
		);
		
		public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
				SYMBOL_LOOKUP.findOrThrow("CoTaskMemFree"),
				DESC);
	}
	
	/**
	 * Function descriptor for:
	 * {@snippet lang = c:
	 * extern void CoTaskMemFree(LPVOID pv)
	 *}
	 */
	public static FunctionDescriptor CoTaskMemFree$descriptor() {
		return CoTaskMemFree.DESC;
	}
	
	/**
	 * Downcall method handle for:
	 * {@snippet lang = c:
	 * extern void CoTaskMemFree(LPVOID pv)
	 *}
	 */
	public static MethodHandle CoTaskMemFree$handle() {
		return CoTaskMemFree.HANDLE;
	}
	
	/**
	 * {@snippet lang = c:
	 * extern void CoTaskMemFree(LPVOID pv)
	 *}
	 */
	public static void CoTaskMemFree(MemorySegment pv) {
		var mh$ = CoTaskMemFree.HANDLE;
		try {
			if ( TRACE_DOWNCALLS ) {
				traceDowncall("CoTaskMemFree", pv);
			}
			mh$.invokeExact(pv);
		} catch (Throwable ex$) {
			throw new AssertionError("should not reach here", ex$);
		}
	}
}
